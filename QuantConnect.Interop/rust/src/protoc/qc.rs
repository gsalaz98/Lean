// This file is generated by rust-protobuf 2.14.0. Do not edit
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![cfg_attr(rustfmt, rustfmt_skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unsafe_code)]
#![allow(unused_imports)]
#![allow(unused_results)]
//! Generated file from `qc.proto`

use protobuf::Message as Message_imported_for_functions;
use protobuf::ProtobufEnum as ProtobufEnum_imported_for_functions;

/// Generated files are compatible only with the same version
/// of protobuf runtime.
// const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_2_14_0;

#[derive(PartialEq,Clone,Default)]
pub struct BaseData {
    // message fields
    pub DataType: MarketDataType,
    pub EndTime: ::protobuf::SingularPtrField<super::bcl::DateTime>,
    pub IsFillForward: bool,
    pub Symbol: ::protobuf::SingularPtrField<Symbol>,
    pub Time: ::protobuf::SingularPtrField<super::bcl::DateTime>,
    pub Value: ::protobuf::SingularPtrField<super::bcl::Decimal>,
    // message oneof groups
    pub subtype: ::std::option::Option<BaseData_oneof_subtype>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a BaseData {
    fn default() -> &'a BaseData {
        <BaseData as ::protobuf::Message>::default_instance()
    }
}

#[derive(Clone,PartialEq,Debug)]
pub enum BaseData_oneof_subtype {
    TradeBar(TradeBar),
    Tick(Tick),
}

impl BaseData {
    pub fn new() -> BaseData {
        ::std::default::Default::default()
    }

    // .MarketDataType DataType = 1;


    pub fn get_DataType(&self) -> MarketDataType {
        self.DataType
    }
    pub fn clear_DataType(&mut self) {
        self.DataType = MarketDataType::BaseType;
    }

    // Param is passed by value, moved
    pub fn set_DataType(&mut self, v: MarketDataType) {
        self.DataType = v;
    }

    // .bcl.DateTime EndTime = 2;


    pub fn get_EndTime(&self) -> &super::bcl::DateTime {
        self.EndTime.as_ref().unwrap_or_else(|| super::bcl::DateTime::default_instance())
    }
    pub fn clear_EndTime(&mut self) {
        self.EndTime.clear();
    }

    pub fn has_EndTime(&self) -> bool {
        self.EndTime.is_some()
    }

    // Param is passed by value, moved
    pub fn set_EndTime(&mut self, v: super::bcl::DateTime) {
        self.EndTime = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_EndTime(&mut self) -> &mut super::bcl::DateTime {
        if self.EndTime.is_none() {
            self.EndTime.set_default();
        }
        self.EndTime.as_mut().unwrap()
    }

    // Take field
    pub fn take_EndTime(&mut self) -> super::bcl::DateTime {
        self.EndTime.take().unwrap_or_else(|| super::bcl::DateTime::new())
    }

    // bool IsFillForward = 3;


    pub fn get_IsFillForward(&self) -> bool {
        self.IsFillForward
    }
    pub fn clear_IsFillForward(&mut self) {
        self.IsFillForward = false;
    }

    // Param is passed by value, moved
    pub fn set_IsFillForward(&mut self, v: bool) {
        self.IsFillForward = v;
    }

    // .Symbol Symbol = 4;


    pub fn get_Symbol(&self) -> &Symbol {
        self.Symbol.as_ref().unwrap_or_else(|| Symbol::default_instance())
    }
    pub fn clear_Symbol(&mut self) {
        self.Symbol.clear();
    }

    pub fn has_Symbol(&self) -> bool {
        self.Symbol.is_some()
    }

    // Param is passed by value, moved
    pub fn set_Symbol(&mut self, v: Symbol) {
        self.Symbol = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_Symbol(&mut self) -> &mut Symbol {
        if self.Symbol.is_none() {
            self.Symbol.set_default();
        }
        self.Symbol.as_mut().unwrap()
    }

    // Take field
    pub fn take_Symbol(&mut self) -> Symbol {
        self.Symbol.take().unwrap_or_else(|| Symbol::new())
    }

    // .bcl.DateTime Time = 5;


    pub fn get_Time(&self) -> &super::bcl::DateTime {
        self.Time.as_ref().unwrap_or_else(|| super::bcl::DateTime::default_instance())
    }
    pub fn clear_Time(&mut self) {
        self.Time.clear();
    }

    pub fn has_Time(&self) -> bool {
        self.Time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_Time(&mut self, v: super::bcl::DateTime) {
        self.Time = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_Time(&mut self) -> &mut super::bcl::DateTime {
        if self.Time.is_none() {
            self.Time.set_default();
        }
        self.Time.as_mut().unwrap()
    }

    // Take field
    pub fn take_Time(&mut self) -> super::bcl::DateTime {
        self.Time.take().unwrap_or_else(|| super::bcl::DateTime::new())
    }

    // .bcl.Decimal Value = 6;


    pub fn get_Value(&self) -> &super::bcl::Decimal {
        self.Value.as_ref().unwrap_or_else(|| super::bcl::Decimal::default_instance())
    }
    pub fn clear_Value(&mut self) {
        self.Value.clear();
    }

    pub fn has_Value(&self) -> bool {
        self.Value.is_some()
    }

    // Param is passed by value, moved
    pub fn set_Value(&mut self, v: super::bcl::Decimal) {
        self.Value = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_Value(&mut self) -> &mut super::bcl::Decimal {
        if self.Value.is_none() {
            self.Value.set_default();
        }
        self.Value.as_mut().unwrap()
    }

    // Take field
    pub fn take_Value(&mut self) -> super::bcl::Decimal {
        self.Value.take().unwrap_or_else(|| super::bcl::Decimal::new())
    }

    // .TradeBar TradeBar = 200;


    pub fn get_TradeBar(&self) -> &TradeBar {
        match self.subtype {
            ::std::option::Option::Some(BaseData_oneof_subtype::TradeBar(ref v)) => v,
            _ => TradeBar::default_instance(),
        }
    }
    pub fn clear_TradeBar(&mut self) {
        self.subtype = ::std::option::Option::None;
    }

    pub fn has_TradeBar(&self) -> bool {
        match self.subtype {
            ::std::option::Option::Some(BaseData_oneof_subtype::TradeBar(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_TradeBar(&mut self, v: TradeBar) {
        self.subtype = ::std::option::Option::Some(BaseData_oneof_subtype::TradeBar(v))
    }

    // Mutable pointer to the field.
    pub fn mut_TradeBar(&mut self) -> &mut TradeBar {
        if let ::std::option::Option::Some(BaseData_oneof_subtype::TradeBar(_)) = self.subtype {
        } else {
            self.subtype = ::std::option::Option::Some(BaseData_oneof_subtype::TradeBar(TradeBar::new()));
        }
        match self.subtype {
            ::std::option::Option::Some(BaseData_oneof_subtype::TradeBar(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_TradeBar(&mut self) -> TradeBar {
        if self.has_TradeBar() {
            match self.subtype.take() {
                ::std::option::Option::Some(BaseData_oneof_subtype::TradeBar(v)) => v,
                _ => panic!(),
            }
        } else {
            TradeBar::new()
        }
    }

    // .Tick Tick = 202;


    pub fn get_Tick(&self) -> &Tick {
        match self.subtype {
            ::std::option::Option::Some(BaseData_oneof_subtype::Tick(ref v)) => v,
            _ => Tick::default_instance(),
        }
    }
    pub fn clear_Tick(&mut self) {
        self.subtype = ::std::option::Option::None;
    }

    pub fn has_Tick(&self) -> bool {
        match self.subtype {
            ::std::option::Option::Some(BaseData_oneof_subtype::Tick(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_Tick(&mut self, v: Tick) {
        self.subtype = ::std::option::Option::Some(BaseData_oneof_subtype::Tick(v))
    }

    // Mutable pointer to the field.
    pub fn mut_Tick(&mut self) -> &mut Tick {
        if let ::std::option::Option::Some(BaseData_oneof_subtype::Tick(_)) = self.subtype {
        } else {
            self.subtype = ::std::option::Option::Some(BaseData_oneof_subtype::Tick(Tick::new()));
        }
        match self.subtype {
            ::std::option::Option::Some(BaseData_oneof_subtype::Tick(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_Tick(&mut self) -> Tick {
        if self.has_Tick() {
            match self.subtype.take() {
                ::std::option::Option::Some(BaseData_oneof_subtype::Tick(v)) => v,
                _ => panic!(),
            }
        } else {
            Tick::new()
        }
    }
}

impl ::protobuf::Message for BaseData {
    fn is_initialized(&self) -> bool {
        for v in &self.EndTime {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.Symbol {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.Time {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.Value {
            if !v.is_initialized() {
                return false;
            }
        };
        if let Some(BaseData_oneof_subtype::TradeBar(ref v)) = self.subtype {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(BaseData_oneof_subtype::Tick(ref v)) = self.subtype {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.DataType, 1, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.EndTime)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.IsFillForward = tmp;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.Symbol)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.Time)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.Value)?;
                },
                200 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.subtype = ::std::option::Option::Some(BaseData_oneof_subtype::TradeBar(is.read_message()?));
                },
                202 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.subtype = ::std::option::Option::Some(BaseData_oneof_subtype::Tick(is.read_message()?));
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.DataType != MarketDataType::BaseType {
            my_size += ::protobuf::rt::enum_size(1, self.DataType);
        }
        if let Some(ref v) = self.EndTime.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.IsFillForward != false {
            my_size += 2;
        }
        if let Some(ref v) = self.Symbol.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.Time.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.Value.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let ::std::option::Option::Some(ref v) = self.subtype {
            match v {
                &BaseData_oneof_subtype::TradeBar(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &BaseData_oneof_subtype::Tick(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.DataType != MarketDataType::BaseType {
            os.write_enum(1, self.DataType.value())?;
        }
        if let Some(ref v) = self.EndTime.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.IsFillForward != false {
            os.write_bool(3, self.IsFillForward)?;
        }
        if let Some(ref v) = self.Symbol.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.Time.as_ref() {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.Value.as_ref() {
            os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let ::std::option::Option::Some(ref v) = self.subtype {
            match v {
                &BaseData_oneof_subtype::TradeBar(ref v) => {
                    os.write_tag(200, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &BaseData_oneof_subtype::Tick(ref v) => {
                    os.write_tag(202, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> BaseData {
        BaseData::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<MarketDataType>>(
                    "DataType",
                    |m: &BaseData| { &m.DataType },
                    |m: &mut BaseData| { &mut m.DataType },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::bcl::DateTime>>(
                    "EndTime",
                    |m: &BaseData| { &m.EndTime },
                    |m: &mut BaseData| { &mut m.EndTime },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "IsFillForward",
                    |m: &BaseData| { &m.IsFillForward },
                    |m: &mut BaseData| { &mut m.IsFillForward },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Symbol>>(
                    "Symbol",
                    |m: &BaseData| { &m.Symbol },
                    |m: &mut BaseData| { &mut m.Symbol },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::bcl::DateTime>>(
                    "Time",
                    |m: &BaseData| { &m.Time },
                    |m: &mut BaseData| { &mut m.Time },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::bcl::Decimal>>(
                    "Value",
                    |m: &BaseData| { &m.Value },
                    |m: &mut BaseData| { &mut m.Value },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, TradeBar>(
                    "TradeBar",
                    BaseData::has_TradeBar,
                    BaseData::get_TradeBar,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, Tick>(
                    "Tick",
                    BaseData::has_Tick,
                    BaseData::get_Tick,
                ));
                ::protobuf::reflect::MessageDescriptor::new_pb_name::<BaseData>(
                    "BaseData",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static BaseData {
        static mut instance: ::protobuf::lazy::Lazy<BaseData> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            instance.get(BaseData::new)
        }
    }
}

impl ::protobuf::Clear for BaseData {
    fn clear(&mut self) {
        self.DataType = MarketDataType::BaseType;
        self.EndTime.clear();
        self.IsFillForward = false;
        self.Symbol.clear();
        self.Time.clear();
        self.Value.clear();
        self.subtype = ::std::option::Option::None;
        self.subtype = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for BaseData {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for BaseData {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct List_BaseData {
    // message fields
    pub items: ::protobuf::RepeatedField<BaseData>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a List_BaseData {
    fn default() -> &'a List_BaseData {
        <List_BaseData as ::protobuf::Message>::default_instance()
    }
}

impl List_BaseData {
    pub fn new() -> List_BaseData {
        ::std::default::Default::default()
    }

    // repeated .BaseData items = 1;


    pub fn get_items(&self) -> &[BaseData] {
        &self.items
    }
    pub fn clear_items(&mut self) {
        self.items.clear();
    }

    // Param is passed by value, moved
    pub fn set_items(&mut self, v: ::protobuf::RepeatedField<BaseData>) {
        self.items = v;
    }

    // Mutable pointer to the field.
    pub fn mut_items(&mut self) -> &mut ::protobuf::RepeatedField<BaseData> {
        &mut self.items
    }

    // Take field
    pub fn take_items(&mut self) -> ::protobuf::RepeatedField<BaseData> {
        ::std::mem::replace(&mut self.items, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for List_BaseData {
    fn is_initialized(&self) -> bool {
        for v in &self.items {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.items)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.items {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.items {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> List_BaseData {
        List_BaseData::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<BaseData>>(
                    "items",
                    |m: &List_BaseData| { &m.items },
                    |m: &mut List_BaseData| { &mut m.items },
                ));
                ::protobuf::reflect::MessageDescriptor::new_pb_name::<List_BaseData>(
                    "List_BaseData",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static List_BaseData {
        static mut instance: ::protobuf::lazy::Lazy<List_BaseData> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            instance.get(List_BaseData::new)
        }
    }
}

impl ::protobuf::Clear for List_BaseData {
    fn clear(&mut self) {
        self.items.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for List_BaseData {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for List_BaseData {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct SecurityIdentifier {
    // message fields
    pub _symbol: ::std::string::String,
    pub _properties: u64,
    pub _underlying: ::protobuf::SingularPtrField<SidBox>,
    pub _hashCode: i32,
    pub _strikePrice: ::protobuf::SingularPtrField<super::bcl::Decimal>,
    pub _optionStyle: OptionStyle,
    pub _optionRight: OptionRight,
    pub _date: ::protobuf::SingularPtrField<super::bcl::DateTime>,
    pub SecurityType: SecurityType,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SecurityIdentifier {
    fn default() -> &'a SecurityIdentifier {
        <SecurityIdentifier as ::protobuf::Message>::default_instance()
    }
}

impl SecurityIdentifier {
    pub fn new() -> SecurityIdentifier {
        ::std::default::Default::default()
    }

    // string _symbol = 1;


    pub fn get__symbol(&self) -> &str {
        &self._symbol
    }
    pub fn clear__symbol(&mut self) {
        self._symbol.clear();
    }

    // Param is passed by value, moved
    pub fn set__symbol(&mut self, v: ::std::string::String) {
        self._symbol = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut__symbol(&mut self) -> &mut ::std::string::String {
        &mut self._symbol
    }

    // Take field
    pub fn take__symbol(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self._symbol, ::std::string::String::new())
    }

    // uint64 _properties = 2;


    pub fn get__properties(&self) -> u64 {
        self._properties
    }
    pub fn clear__properties(&mut self) {
        self._properties = 0;
    }

    // Param is passed by value, moved
    pub fn set__properties(&mut self, v: u64) {
        self._properties = v;
    }

    // .SidBox _underlying = 3;


    pub fn get__underlying(&self) -> &SidBox {
        self._underlying.as_ref().unwrap_or_else(|| SidBox::default_instance())
    }
    pub fn clear__underlying(&mut self) {
        self._underlying.clear();
    }

    pub fn has__underlying(&self) -> bool {
        self._underlying.is_some()
    }

    // Param is passed by value, moved
    pub fn set__underlying(&mut self, v: SidBox) {
        self._underlying = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut__underlying(&mut self) -> &mut SidBox {
        if self._underlying.is_none() {
            self._underlying.set_default();
        }
        self._underlying.as_mut().unwrap()
    }

    // Take field
    pub fn take__underlying(&mut self) -> SidBox {
        self._underlying.take().unwrap_or_else(|| SidBox::new())
    }

    // int32 _hashCode = 4;


    pub fn get__hashCode(&self) -> i32 {
        self._hashCode
    }
    pub fn clear__hashCode(&mut self) {
        self._hashCode = 0;
    }

    // Param is passed by value, moved
    pub fn set__hashCode(&mut self, v: i32) {
        self._hashCode = v;
    }

    // .bcl.Decimal _strikePrice = 5;


    pub fn get__strikePrice(&self) -> &super::bcl::Decimal {
        self._strikePrice.as_ref().unwrap_or_else(|| super::bcl::Decimal::default_instance())
    }
    pub fn clear__strikePrice(&mut self) {
        self._strikePrice.clear();
    }

    pub fn has__strikePrice(&self) -> bool {
        self._strikePrice.is_some()
    }

    // Param is passed by value, moved
    pub fn set__strikePrice(&mut self, v: super::bcl::Decimal) {
        self._strikePrice = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut__strikePrice(&mut self) -> &mut super::bcl::Decimal {
        if self._strikePrice.is_none() {
            self._strikePrice.set_default();
        }
        self._strikePrice.as_mut().unwrap()
    }

    // Take field
    pub fn take__strikePrice(&mut self) -> super::bcl::Decimal {
        self._strikePrice.take().unwrap_or_else(|| super::bcl::Decimal::new())
    }

    // .OptionStyle _optionStyle = 6;


    pub fn get__optionStyle(&self) -> OptionStyle {
        self._optionStyle
    }
    pub fn clear__optionStyle(&mut self) {
        self._optionStyle = OptionStyle::American;
    }

    // Param is passed by value, moved
    pub fn set__optionStyle(&mut self, v: OptionStyle) {
        self._optionStyle = v;
    }

    // .OptionRight _optionRight = 7;


    pub fn get__optionRight(&self) -> OptionRight {
        self._optionRight
    }
    pub fn clear__optionRight(&mut self) {
        self._optionRight = OptionRight::Call;
    }

    // Param is passed by value, moved
    pub fn set__optionRight(&mut self, v: OptionRight) {
        self._optionRight = v;
    }

    // .bcl.DateTime _date = 8;


    pub fn get__date(&self) -> &super::bcl::DateTime {
        self._date.as_ref().unwrap_or_else(|| super::bcl::DateTime::default_instance())
    }
    pub fn clear__date(&mut self) {
        self._date.clear();
    }

    pub fn has__date(&self) -> bool {
        self._date.is_some()
    }

    // Param is passed by value, moved
    pub fn set__date(&mut self, v: super::bcl::DateTime) {
        self._date = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut__date(&mut self) -> &mut super::bcl::DateTime {
        if self._date.is_none() {
            self._date.set_default();
        }
        self._date.as_mut().unwrap()
    }

    // Take field
    pub fn take__date(&mut self) -> super::bcl::DateTime {
        self._date.take().unwrap_or_else(|| super::bcl::DateTime::new())
    }

    // .SecurityType SecurityType = 9;


    pub fn get_SecurityType(&self) -> SecurityType {
        self.SecurityType
    }
    pub fn clear_SecurityType(&mut self) {
        self.SecurityType = SecurityType::Base;
    }

    // Param is passed by value, moved
    pub fn set_SecurityType(&mut self, v: SecurityType) {
        self.SecurityType = v;
    }
}

impl ::protobuf::Message for SecurityIdentifier {
    fn is_initialized(&self) -> bool {
        for v in &self._underlying {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self._strikePrice {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self._date {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self._symbol)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self._properties = tmp;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self._underlying)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self._hashCode = tmp;
                },
                5 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self._strikePrice)?;
                },
                6 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self._optionStyle, 6, &mut self.unknown_fields)?
                },
                7 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self._optionRight, 7, &mut self.unknown_fields)?
                },
                8 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self._date)?;
                },
                9 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.SecurityType, 9, &mut self.unknown_fields)?
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self._symbol.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self._symbol);
        }
        if self._properties != 0 {
            my_size += ::protobuf::rt::value_size(2, self._properties, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self._underlying.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self._hashCode != 0 {
            my_size += ::protobuf::rt::value_size(4, self._hashCode, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self._strikePrice.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self._optionStyle != OptionStyle::American {
            my_size += ::protobuf::rt::enum_size(6, self._optionStyle);
        }
        if self._optionRight != OptionRight::Call {
            my_size += ::protobuf::rt::enum_size(7, self._optionRight);
        }
        if let Some(ref v) = self._date.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.SecurityType != SecurityType::Base {
            my_size += ::protobuf::rt::enum_size(9, self.SecurityType);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self._symbol.is_empty() {
            os.write_string(1, &self._symbol)?;
        }
        if self._properties != 0 {
            os.write_uint64(2, self._properties)?;
        }
        if let Some(ref v) = self._underlying.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self._hashCode != 0 {
            os.write_int32(4, self._hashCode)?;
        }
        if let Some(ref v) = self._strikePrice.as_ref() {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self._optionStyle != OptionStyle::American {
            os.write_enum(6, self._optionStyle.value())?;
        }
        if self._optionRight != OptionRight::Call {
            os.write_enum(7, self._optionRight.value())?;
        }
        if let Some(ref v) = self._date.as_ref() {
            os.write_tag(8, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.SecurityType != SecurityType::Base {
            os.write_enum(9, self.SecurityType.value())?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SecurityIdentifier {
        SecurityIdentifier::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "_symbol",
                    |m: &SecurityIdentifier| { &m._symbol },
                    |m: &mut SecurityIdentifier| { &mut m._symbol },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "_properties",
                    |m: &SecurityIdentifier| { &m._properties },
                    |m: &mut SecurityIdentifier| { &mut m._properties },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<SidBox>>(
                    "_underlying",
                    |m: &SecurityIdentifier| { &m._underlying },
                    |m: &mut SecurityIdentifier| { &mut m._underlying },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "_hashCode",
                    |m: &SecurityIdentifier| { &m._hashCode },
                    |m: &mut SecurityIdentifier| { &mut m._hashCode },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::bcl::Decimal>>(
                    "_strikePrice",
                    |m: &SecurityIdentifier| { &m._strikePrice },
                    |m: &mut SecurityIdentifier| { &mut m._strikePrice },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<OptionStyle>>(
                    "_optionStyle",
                    |m: &SecurityIdentifier| { &m._optionStyle },
                    |m: &mut SecurityIdentifier| { &mut m._optionStyle },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<OptionRight>>(
                    "_optionRight",
                    |m: &SecurityIdentifier| { &m._optionRight },
                    |m: &mut SecurityIdentifier| { &mut m._optionRight },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::bcl::DateTime>>(
                    "_date",
                    |m: &SecurityIdentifier| { &m._date },
                    |m: &mut SecurityIdentifier| { &mut m._date },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<SecurityType>>(
                    "SecurityType",
                    |m: &SecurityIdentifier| { &m.SecurityType },
                    |m: &mut SecurityIdentifier| { &mut m.SecurityType },
                ));
                ::protobuf::reflect::MessageDescriptor::new_pb_name::<SecurityIdentifier>(
                    "SecurityIdentifier",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static SecurityIdentifier {
        static mut instance: ::protobuf::lazy::Lazy<SecurityIdentifier> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            instance.get(SecurityIdentifier::new)
        }
    }
}

impl ::protobuf::Clear for SecurityIdentifier {
    fn clear(&mut self) {
        self._symbol.clear();
        self._properties = 0;
        self._underlying.clear();
        self._hashCode = 0;
        self._strikePrice.clear();
        self._optionStyle = OptionStyle::American;
        self._optionRight = OptionRight::Call;
        self._date.clear();
        self.SecurityType = SecurityType::Base;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SecurityIdentifier {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SecurityIdentifier {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct SidBox {
    // message fields
    pub SecurityIdentifier: ::protobuf::SingularPtrField<SecurityIdentifier>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SidBox {
    fn default() -> &'a SidBox {
        <SidBox as ::protobuf::Message>::default_instance()
    }
}

impl SidBox {
    pub fn new() -> SidBox {
        ::std::default::Default::default()
    }

    // .SecurityIdentifier SecurityIdentifier = 1;


    pub fn get_SecurityIdentifier(&self) -> &SecurityIdentifier {
        self.SecurityIdentifier.as_ref().unwrap_or_else(|| SecurityIdentifier::default_instance())
    }
    pub fn clear_SecurityIdentifier(&mut self) {
        self.SecurityIdentifier.clear();
    }

    pub fn has_SecurityIdentifier(&self) -> bool {
        self.SecurityIdentifier.is_some()
    }

    // Param is passed by value, moved
    pub fn set_SecurityIdentifier(&mut self, v: SecurityIdentifier) {
        self.SecurityIdentifier = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_SecurityIdentifier(&mut self) -> &mut SecurityIdentifier {
        if self.SecurityIdentifier.is_none() {
            self.SecurityIdentifier.set_default();
        }
        self.SecurityIdentifier.as_mut().unwrap()
    }

    // Take field
    pub fn take_SecurityIdentifier(&mut self) -> SecurityIdentifier {
        self.SecurityIdentifier.take().unwrap_or_else(|| SecurityIdentifier::new())
    }
}

impl ::protobuf::Message for SidBox {
    fn is_initialized(&self) -> bool {
        for v in &self.SecurityIdentifier {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.SecurityIdentifier)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.SecurityIdentifier.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.SecurityIdentifier.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SidBox {
        SidBox::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<SecurityIdentifier>>(
                    "SecurityIdentifier",
                    |m: &SidBox| { &m.SecurityIdentifier },
                    |m: &mut SidBox| { &mut m.SecurityIdentifier },
                ));
                ::protobuf::reflect::MessageDescriptor::new_pb_name::<SidBox>(
                    "SidBox",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static SidBox {
        static mut instance: ::protobuf::lazy::Lazy<SidBox> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            instance.get(SidBox::new)
        }
    }
}

impl ::protobuf::Clear for SidBox {
    fn clear(&mut self) {
        self.SecurityIdentifier.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SidBox {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SidBox {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Symbol {
    // message fields
    pub HasUnderlying: bool,
    pub ID: ::protobuf::SingularPtrField<SecurityIdentifier>,
    pub SecurityType: SecurityType,
    pub Underlying: ::protobuf::SingularPtrField<Symbol>,
    pub Value: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Symbol {
    fn default() -> &'a Symbol {
        <Symbol as ::protobuf::Message>::default_instance()
    }
}

impl Symbol {
    pub fn new() -> Symbol {
        ::std::default::Default::default()
    }

    // bool HasUnderlying = 1;


    pub fn get_HasUnderlying(&self) -> bool {
        self.HasUnderlying
    }
    pub fn clear_HasUnderlying(&mut self) {
        self.HasUnderlying = false;
    }

    // Param is passed by value, moved
    pub fn set_HasUnderlying(&mut self, v: bool) {
        self.HasUnderlying = v;
    }

    // .SecurityIdentifier ID = 2;


    pub fn get_ID(&self) -> &SecurityIdentifier {
        self.ID.as_ref().unwrap_or_else(|| SecurityIdentifier::default_instance())
    }
    pub fn clear_ID(&mut self) {
        self.ID.clear();
    }

    pub fn has_ID(&self) -> bool {
        self.ID.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ID(&mut self, v: SecurityIdentifier) {
        self.ID = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_ID(&mut self) -> &mut SecurityIdentifier {
        if self.ID.is_none() {
            self.ID.set_default();
        }
        self.ID.as_mut().unwrap()
    }

    // Take field
    pub fn take_ID(&mut self) -> SecurityIdentifier {
        self.ID.take().unwrap_or_else(|| SecurityIdentifier::new())
    }

    // .SecurityType SecurityType = 3;


    pub fn get_SecurityType(&self) -> SecurityType {
        self.SecurityType
    }
    pub fn clear_SecurityType(&mut self) {
        self.SecurityType = SecurityType::Base;
    }

    // Param is passed by value, moved
    pub fn set_SecurityType(&mut self, v: SecurityType) {
        self.SecurityType = v;
    }

    // .Symbol Underlying = 4;


    pub fn get_Underlying(&self) -> &Symbol {
        self.Underlying.as_ref().unwrap_or_else(|| Symbol::default_instance())
    }
    pub fn clear_Underlying(&mut self) {
        self.Underlying.clear();
    }

    pub fn has_Underlying(&self) -> bool {
        self.Underlying.is_some()
    }

    // Param is passed by value, moved
    pub fn set_Underlying(&mut self, v: Symbol) {
        self.Underlying = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_Underlying(&mut self) -> &mut Symbol {
        if self.Underlying.is_none() {
            self.Underlying.set_default();
        }
        self.Underlying.as_mut().unwrap()
    }

    // Take field
    pub fn take_Underlying(&mut self) -> Symbol {
        self.Underlying.take().unwrap_or_else(|| Symbol::new())
    }

    // string Value = 5;


    pub fn get_Value(&self) -> &str {
        &self.Value
    }
    pub fn clear_Value(&mut self) {
        self.Value.clear();
    }

    // Param is passed by value, moved
    pub fn set_Value(&mut self, v: ::std::string::String) {
        self.Value = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_Value(&mut self) -> &mut ::std::string::String {
        &mut self.Value
    }

    // Take field
    pub fn take_Value(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.Value, ::std::string::String::new())
    }
}

impl ::protobuf::Message for Symbol {
    fn is_initialized(&self) -> bool {
        for v in &self.ID {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.Underlying {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.HasUnderlying = tmp;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.ID)?;
                },
                3 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.SecurityType, 3, &mut self.unknown_fields)?
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.Underlying)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.Value)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.HasUnderlying != false {
            my_size += 2;
        }
        if let Some(ref v) = self.ID.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.SecurityType != SecurityType::Base {
            my_size += ::protobuf::rt::enum_size(3, self.SecurityType);
        }
        if let Some(ref v) = self.Underlying.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.Value.is_empty() {
            my_size += ::protobuf::rt::string_size(5, &self.Value);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.HasUnderlying != false {
            os.write_bool(1, self.HasUnderlying)?;
        }
        if let Some(ref v) = self.ID.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.SecurityType != SecurityType::Base {
            os.write_enum(3, self.SecurityType.value())?;
        }
        if let Some(ref v) = self.Underlying.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.Value.is_empty() {
            os.write_string(5, &self.Value)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Symbol {
        Symbol::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "HasUnderlying",
                    |m: &Symbol| { &m.HasUnderlying },
                    |m: &mut Symbol| { &mut m.HasUnderlying },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<SecurityIdentifier>>(
                    "ID",
                    |m: &Symbol| { &m.ID },
                    |m: &mut Symbol| { &mut m.ID },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<SecurityType>>(
                    "SecurityType",
                    |m: &Symbol| { &m.SecurityType },
                    |m: &mut Symbol| { &mut m.SecurityType },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Symbol>>(
                    "Underlying",
                    |m: &Symbol| { &m.Underlying },
                    |m: &mut Symbol| { &mut m.Underlying },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "Value",
                    |m: &Symbol| { &m.Value },
                    |m: &mut Symbol| { &mut m.Value },
                ));
                ::protobuf::reflect::MessageDescriptor::new_pb_name::<Symbol>(
                    "Symbol",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Symbol {
        static mut instance: ::protobuf::lazy::Lazy<Symbol> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            instance.get(Symbol::new)
        }
    }
}

impl ::protobuf::Clear for Symbol {
    fn clear(&mut self) {
        self.HasUnderlying = false;
        self.ID.clear();
        self.SecurityType = SecurityType::Base;
        self.Underlying.clear();
        self.Value.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Symbol {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Symbol {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Tick {
    // message fields
    pub AskPrice: ::protobuf::SingularPtrField<super::bcl::Decimal>,
    pub AskSize: ::protobuf::SingularPtrField<super::bcl::Decimal>,
    pub BidPrice: ::protobuf::SingularPtrField<super::bcl::Decimal>,
    pub BidSize: ::protobuf::SingularPtrField<super::bcl::Decimal>,
    pub Exchange: ::std::string::String,
    pub Quantity: ::protobuf::SingularPtrField<super::bcl::Decimal>,
    pub SaleCondition: ::std::string::String,
    pub Suspicious: bool,
    pub TickType: TickType,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Tick {
    fn default() -> &'a Tick {
        <Tick as ::protobuf::Message>::default_instance()
    }
}

impl Tick {
    pub fn new() -> Tick {
        ::std::default::Default::default()
    }

    // .bcl.Decimal AskPrice = 1;


    pub fn get_AskPrice(&self) -> &super::bcl::Decimal {
        self.AskPrice.as_ref().unwrap_or_else(|| super::bcl::Decimal::default_instance())
    }
    pub fn clear_AskPrice(&mut self) {
        self.AskPrice.clear();
    }

    pub fn has_AskPrice(&self) -> bool {
        self.AskPrice.is_some()
    }

    // Param is passed by value, moved
    pub fn set_AskPrice(&mut self, v: super::bcl::Decimal) {
        self.AskPrice = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_AskPrice(&mut self) -> &mut super::bcl::Decimal {
        if self.AskPrice.is_none() {
            self.AskPrice.set_default();
        }
        self.AskPrice.as_mut().unwrap()
    }

    // Take field
    pub fn take_AskPrice(&mut self) -> super::bcl::Decimal {
        self.AskPrice.take().unwrap_or_else(|| super::bcl::Decimal::new())
    }

    // .bcl.Decimal AskSize = 2;


    pub fn get_AskSize(&self) -> &super::bcl::Decimal {
        self.AskSize.as_ref().unwrap_or_else(|| super::bcl::Decimal::default_instance())
    }
    pub fn clear_AskSize(&mut self) {
        self.AskSize.clear();
    }

    pub fn has_AskSize(&self) -> bool {
        self.AskSize.is_some()
    }

    // Param is passed by value, moved
    pub fn set_AskSize(&mut self, v: super::bcl::Decimal) {
        self.AskSize = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_AskSize(&mut self) -> &mut super::bcl::Decimal {
        if self.AskSize.is_none() {
            self.AskSize.set_default();
        }
        self.AskSize.as_mut().unwrap()
    }

    // Take field
    pub fn take_AskSize(&mut self) -> super::bcl::Decimal {
        self.AskSize.take().unwrap_or_else(|| super::bcl::Decimal::new())
    }

    // .bcl.Decimal BidPrice = 3;


    pub fn get_BidPrice(&self) -> &super::bcl::Decimal {
        self.BidPrice.as_ref().unwrap_or_else(|| super::bcl::Decimal::default_instance())
    }
    pub fn clear_BidPrice(&mut self) {
        self.BidPrice.clear();
    }

    pub fn has_BidPrice(&self) -> bool {
        self.BidPrice.is_some()
    }

    // Param is passed by value, moved
    pub fn set_BidPrice(&mut self, v: super::bcl::Decimal) {
        self.BidPrice = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_BidPrice(&mut self) -> &mut super::bcl::Decimal {
        if self.BidPrice.is_none() {
            self.BidPrice.set_default();
        }
        self.BidPrice.as_mut().unwrap()
    }

    // Take field
    pub fn take_BidPrice(&mut self) -> super::bcl::Decimal {
        self.BidPrice.take().unwrap_or_else(|| super::bcl::Decimal::new())
    }

    // .bcl.Decimal BidSize = 4;


    pub fn get_BidSize(&self) -> &super::bcl::Decimal {
        self.BidSize.as_ref().unwrap_or_else(|| super::bcl::Decimal::default_instance())
    }
    pub fn clear_BidSize(&mut self) {
        self.BidSize.clear();
    }

    pub fn has_BidSize(&self) -> bool {
        self.BidSize.is_some()
    }

    // Param is passed by value, moved
    pub fn set_BidSize(&mut self, v: super::bcl::Decimal) {
        self.BidSize = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_BidSize(&mut self) -> &mut super::bcl::Decimal {
        if self.BidSize.is_none() {
            self.BidSize.set_default();
        }
        self.BidSize.as_mut().unwrap()
    }

    // Take field
    pub fn take_BidSize(&mut self) -> super::bcl::Decimal {
        self.BidSize.take().unwrap_or_else(|| super::bcl::Decimal::new())
    }

    // string Exchange = 5;


    pub fn get_Exchange(&self) -> &str {
        &self.Exchange
    }
    pub fn clear_Exchange(&mut self) {
        self.Exchange.clear();
    }

    // Param is passed by value, moved
    pub fn set_Exchange(&mut self, v: ::std::string::String) {
        self.Exchange = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_Exchange(&mut self) -> &mut ::std::string::String {
        &mut self.Exchange
    }

    // Take field
    pub fn take_Exchange(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.Exchange, ::std::string::String::new())
    }

    // .bcl.Decimal Quantity = 6;


    pub fn get_Quantity(&self) -> &super::bcl::Decimal {
        self.Quantity.as_ref().unwrap_or_else(|| super::bcl::Decimal::default_instance())
    }
    pub fn clear_Quantity(&mut self) {
        self.Quantity.clear();
    }

    pub fn has_Quantity(&self) -> bool {
        self.Quantity.is_some()
    }

    // Param is passed by value, moved
    pub fn set_Quantity(&mut self, v: super::bcl::Decimal) {
        self.Quantity = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_Quantity(&mut self) -> &mut super::bcl::Decimal {
        if self.Quantity.is_none() {
            self.Quantity.set_default();
        }
        self.Quantity.as_mut().unwrap()
    }

    // Take field
    pub fn take_Quantity(&mut self) -> super::bcl::Decimal {
        self.Quantity.take().unwrap_or_else(|| super::bcl::Decimal::new())
    }

    // string SaleCondition = 7;


    pub fn get_SaleCondition(&self) -> &str {
        &self.SaleCondition
    }
    pub fn clear_SaleCondition(&mut self) {
        self.SaleCondition.clear();
    }

    // Param is passed by value, moved
    pub fn set_SaleCondition(&mut self, v: ::std::string::String) {
        self.SaleCondition = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_SaleCondition(&mut self) -> &mut ::std::string::String {
        &mut self.SaleCondition
    }

    // Take field
    pub fn take_SaleCondition(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.SaleCondition, ::std::string::String::new())
    }

    // bool Suspicious = 8;


    pub fn get_Suspicious(&self) -> bool {
        self.Suspicious
    }
    pub fn clear_Suspicious(&mut self) {
        self.Suspicious = false;
    }

    // Param is passed by value, moved
    pub fn set_Suspicious(&mut self, v: bool) {
        self.Suspicious = v;
    }

    // .TickType TickType = 9;


    pub fn get_TickType(&self) -> TickType {
        self.TickType
    }
    pub fn clear_TickType(&mut self) {
        self.TickType = TickType::Trade;
    }

    // Param is passed by value, moved
    pub fn set_TickType(&mut self, v: TickType) {
        self.TickType = v;
    }
}

impl ::protobuf::Message for Tick {
    fn is_initialized(&self) -> bool {
        for v in &self.AskPrice {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.AskSize {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.BidPrice {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.BidSize {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.Quantity {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.AskPrice)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.AskSize)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.BidPrice)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.BidSize)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.Exchange)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.Quantity)?;
                },
                7 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.SaleCondition)?;
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.Suspicious = tmp;
                },
                9 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.TickType, 9, &mut self.unknown_fields)?
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.AskPrice.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.AskSize.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.BidPrice.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.BidSize.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.Exchange.is_empty() {
            my_size += ::protobuf::rt::string_size(5, &self.Exchange);
        }
        if let Some(ref v) = self.Quantity.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.SaleCondition.is_empty() {
            my_size += ::protobuf::rt::string_size(7, &self.SaleCondition);
        }
        if self.Suspicious != false {
            my_size += 2;
        }
        if self.TickType != TickType::Trade {
            my_size += ::protobuf::rt::enum_size(9, self.TickType);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.AskPrice.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.AskSize.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.BidPrice.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.BidSize.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.Exchange.is_empty() {
            os.write_string(5, &self.Exchange)?;
        }
        if let Some(ref v) = self.Quantity.as_ref() {
            os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.SaleCondition.is_empty() {
            os.write_string(7, &self.SaleCondition)?;
        }
        if self.Suspicious != false {
            os.write_bool(8, self.Suspicious)?;
        }
        if self.TickType != TickType::Trade {
            os.write_enum(9, self.TickType.value())?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Tick {
        Tick::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::bcl::Decimal>>(
                    "AskPrice",
                    |m: &Tick| { &m.AskPrice },
                    |m: &mut Tick| { &mut m.AskPrice },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::bcl::Decimal>>(
                    "AskSize",
                    |m: &Tick| { &m.AskSize },
                    |m: &mut Tick| { &mut m.AskSize },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::bcl::Decimal>>(
                    "BidPrice",
                    |m: &Tick| { &m.BidPrice },
                    |m: &mut Tick| { &mut m.BidPrice },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::bcl::Decimal>>(
                    "BidSize",
                    |m: &Tick| { &m.BidSize },
                    |m: &mut Tick| { &mut m.BidSize },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "Exchange",
                    |m: &Tick| { &m.Exchange },
                    |m: &mut Tick| { &mut m.Exchange },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::bcl::Decimal>>(
                    "Quantity",
                    |m: &Tick| { &m.Quantity },
                    |m: &mut Tick| { &mut m.Quantity },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "SaleCondition",
                    |m: &Tick| { &m.SaleCondition },
                    |m: &mut Tick| { &mut m.SaleCondition },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "Suspicious",
                    |m: &Tick| { &m.Suspicious },
                    |m: &mut Tick| { &mut m.Suspicious },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<TickType>>(
                    "TickType",
                    |m: &Tick| { &m.TickType },
                    |m: &mut Tick| { &mut m.TickType },
                ));
                ::protobuf::reflect::MessageDescriptor::new_pb_name::<Tick>(
                    "Tick",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Tick {
        static mut instance: ::protobuf::lazy::Lazy<Tick> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            instance.get(Tick::new)
        }
    }
}

impl ::protobuf::Clear for Tick {
    fn clear(&mut self) {
        self.AskPrice.clear();
        self.AskSize.clear();
        self.BidPrice.clear();
        self.BidSize.clear();
        self.Exchange.clear();
        self.Quantity.clear();
        self.SaleCondition.clear();
        self.Suspicious = false;
        self.TickType = TickType::Trade;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Tick {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Tick {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct TradeBar {
    // message fields
    pub Close: ::protobuf::SingularPtrField<super::bcl::Decimal>,
    pub EndTime: ::protobuf::SingularPtrField<super::bcl::DateTime>,
    pub High: ::protobuf::SingularPtrField<super::bcl::Decimal>,
    pub Low: ::protobuf::SingularPtrField<super::bcl::Decimal>,
    pub Open: ::protobuf::SingularPtrField<super::bcl::Decimal>,
    pub Period: ::protobuf::SingularPtrField<super::bcl::TimeSpan>,
    pub Volume: ::protobuf::SingularPtrField<super::bcl::Decimal>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a TradeBar {
    fn default() -> &'a TradeBar {
        <TradeBar as ::protobuf::Message>::default_instance()
    }
}

impl TradeBar {
    pub fn new() -> TradeBar {
        ::std::default::Default::default()
    }

    // .bcl.Decimal Close = 1;


    pub fn get_Close(&self) -> &super::bcl::Decimal {
        self.Close.as_ref().unwrap_or_else(|| super::bcl::Decimal::default_instance())
    }
    pub fn clear_Close(&mut self) {
        self.Close.clear();
    }

    pub fn has_Close(&self) -> bool {
        self.Close.is_some()
    }

    // Param is passed by value, moved
    pub fn set_Close(&mut self, v: super::bcl::Decimal) {
        self.Close = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_Close(&mut self) -> &mut super::bcl::Decimal {
        if self.Close.is_none() {
            self.Close.set_default();
        }
        self.Close.as_mut().unwrap()
    }

    // Take field
    pub fn take_Close(&mut self) -> super::bcl::Decimal {
        self.Close.take().unwrap_or_else(|| super::bcl::Decimal::new())
    }

    // .bcl.DateTime EndTime = 2;


    pub fn get_EndTime(&self) -> &super::bcl::DateTime {
        self.EndTime.as_ref().unwrap_or_else(|| super::bcl::DateTime::default_instance())
    }
    pub fn clear_EndTime(&mut self) {
        self.EndTime.clear();
    }

    pub fn has_EndTime(&self) -> bool {
        self.EndTime.is_some()
    }

    // Param is passed by value, moved
    pub fn set_EndTime(&mut self, v: super::bcl::DateTime) {
        self.EndTime = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_EndTime(&mut self) -> &mut super::bcl::DateTime {
        if self.EndTime.is_none() {
            self.EndTime.set_default();
        }
        self.EndTime.as_mut().unwrap()
    }

    // Take field
    pub fn take_EndTime(&mut self) -> super::bcl::DateTime {
        self.EndTime.take().unwrap_or_else(|| super::bcl::DateTime::new())
    }

    // .bcl.Decimal High = 3;


    pub fn get_High(&self) -> &super::bcl::Decimal {
        self.High.as_ref().unwrap_or_else(|| super::bcl::Decimal::default_instance())
    }
    pub fn clear_High(&mut self) {
        self.High.clear();
    }

    pub fn has_High(&self) -> bool {
        self.High.is_some()
    }

    // Param is passed by value, moved
    pub fn set_High(&mut self, v: super::bcl::Decimal) {
        self.High = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_High(&mut self) -> &mut super::bcl::Decimal {
        if self.High.is_none() {
            self.High.set_default();
        }
        self.High.as_mut().unwrap()
    }

    // Take field
    pub fn take_High(&mut self) -> super::bcl::Decimal {
        self.High.take().unwrap_or_else(|| super::bcl::Decimal::new())
    }

    // .bcl.Decimal Low = 4;


    pub fn get_Low(&self) -> &super::bcl::Decimal {
        self.Low.as_ref().unwrap_or_else(|| super::bcl::Decimal::default_instance())
    }
    pub fn clear_Low(&mut self) {
        self.Low.clear();
    }

    pub fn has_Low(&self) -> bool {
        self.Low.is_some()
    }

    // Param is passed by value, moved
    pub fn set_Low(&mut self, v: super::bcl::Decimal) {
        self.Low = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_Low(&mut self) -> &mut super::bcl::Decimal {
        if self.Low.is_none() {
            self.Low.set_default();
        }
        self.Low.as_mut().unwrap()
    }

    // Take field
    pub fn take_Low(&mut self) -> super::bcl::Decimal {
        self.Low.take().unwrap_or_else(|| super::bcl::Decimal::new())
    }

    // .bcl.Decimal Open = 5;


    pub fn get_Open(&self) -> &super::bcl::Decimal {
        self.Open.as_ref().unwrap_or_else(|| super::bcl::Decimal::default_instance())
    }
    pub fn clear_Open(&mut self) {
        self.Open.clear();
    }

    pub fn has_Open(&self) -> bool {
        self.Open.is_some()
    }

    // Param is passed by value, moved
    pub fn set_Open(&mut self, v: super::bcl::Decimal) {
        self.Open = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_Open(&mut self) -> &mut super::bcl::Decimal {
        if self.Open.is_none() {
            self.Open.set_default();
        }
        self.Open.as_mut().unwrap()
    }

    // Take field
    pub fn take_Open(&mut self) -> super::bcl::Decimal {
        self.Open.take().unwrap_or_else(|| super::bcl::Decimal::new())
    }

    // .bcl.TimeSpan Period = 6;


    pub fn get_Period(&self) -> &super::bcl::TimeSpan {
        self.Period.as_ref().unwrap_or_else(|| super::bcl::TimeSpan::default_instance())
    }
    pub fn clear_Period(&mut self) {
        self.Period.clear();
    }

    pub fn has_Period(&self) -> bool {
        self.Period.is_some()
    }

    // Param is passed by value, moved
    pub fn set_Period(&mut self, v: super::bcl::TimeSpan) {
        self.Period = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_Period(&mut self) -> &mut super::bcl::TimeSpan {
        if self.Period.is_none() {
            self.Period.set_default();
        }
        self.Period.as_mut().unwrap()
    }

    // Take field
    pub fn take_Period(&mut self) -> super::bcl::TimeSpan {
        self.Period.take().unwrap_or_else(|| super::bcl::TimeSpan::new())
    }

    // .bcl.Decimal Volume = 7;


    pub fn get_Volume(&self) -> &super::bcl::Decimal {
        self.Volume.as_ref().unwrap_or_else(|| super::bcl::Decimal::default_instance())
    }
    pub fn clear_Volume(&mut self) {
        self.Volume.clear();
    }

    pub fn has_Volume(&self) -> bool {
        self.Volume.is_some()
    }

    // Param is passed by value, moved
    pub fn set_Volume(&mut self, v: super::bcl::Decimal) {
        self.Volume = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_Volume(&mut self) -> &mut super::bcl::Decimal {
        if self.Volume.is_none() {
            self.Volume.set_default();
        }
        self.Volume.as_mut().unwrap()
    }

    // Take field
    pub fn take_Volume(&mut self) -> super::bcl::Decimal {
        self.Volume.take().unwrap_or_else(|| super::bcl::Decimal::new())
    }
}

impl ::protobuf::Message for TradeBar {
    fn is_initialized(&self) -> bool {
        for v in &self.Close {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.EndTime {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.High {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.Low {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.Open {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.Period {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.Volume {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.Close)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.EndTime)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.High)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.Low)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.Open)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.Period)?;
                },
                7 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.Volume)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.Close.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.EndTime.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.High.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.Low.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.Open.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.Period.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.Volume.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.Close.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.EndTime.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.High.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.Low.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.Open.as_ref() {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.Period.as_ref() {
            os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.Volume.as_ref() {
            os.write_tag(7, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> TradeBar {
        TradeBar::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::bcl::Decimal>>(
                    "Close",
                    |m: &TradeBar| { &m.Close },
                    |m: &mut TradeBar| { &mut m.Close },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::bcl::DateTime>>(
                    "EndTime",
                    |m: &TradeBar| { &m.EndTime },
                    |m: &mut TradeBar| { &mut m.EndTime },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::bcl::Decimal>>(
                    "High",
                    |m: &TradeBar| { &m.High },
                    |m: &mut TradeBar| { &mut m.High },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::bcl::Decimal>>(
                    "Low",
                    |m: &TradeBar| { &m.Low },
                    |m: &mut TradeBar| { &mut m.Low },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::bcl::Decimal>>(
                    "Open",
                    |m: &TradeBar| { &m.Open },
                    |m: &mut TradeBar| { &mut m.Open },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::bcl::TimeSpan>>(
                    "Period",
                    |m: &TradeBar| { &m.Period },
                    |m: &mut TradeBar| { &mut m.Period },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::bcl::Decimal>>(
                    "Volume",
                    |m: &TradeBar| { &m.Volume },
                    |m: &mut TradeBar| { &mut m.Volume },
                ));
                ::protobuf::reflect::MessageDescriptor::new_pb_name::<TradeBar>(
                    "TradeBar",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static TradeBar {
        static mut instance: ::protobuf::lazy::Lazy<TradeBar> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            instance.get(TradeBar::new)
        }
    }
}

impl ::protobuf::Clear for TradeBar {
    fn clear(&mut self) {
        self.Close.clear();
        self.EndTime.clear();
        self.High.clear();
        self.Low.clear();
        self.Open.clear();
        self.Period.clear();
        self.Volume.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for TradeBar {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TradeBar {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum MarketDataType {
    BaseType = 0,
    TradeBarType = 1,
    TickTypeType = 2,
    AuxiliaryType = 3,
    QuoteBarType = 4,
    OptionChainType = 5,
    FuturesChainType = 6,
}

impl ::protobuf::ProtobufEnum for MarketDataType {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<MarketDataType> {
        match value {
            0 => ::std::option::Option::Some(MarketDataType::BaseType),
            1 => ::std::option::Option::Some(MarketDataType::TradeBarType),
            2 => ::std::option::Option::Some(MarketDataType::TickTypeType),
            3 => ::std::option::Option::Some(MarketDataType::AuxiliaryType),
            4 => ::std::option::Option::Some(MarketDataType::QuoteBarType),
            5 => ::std::option::Option::Some(MarketDataType::OptionChainType),
            6 => ::std::option::Option::Some(MarketDataType::FuturesChainType),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [MarketDataType] = &[
            MarketDataType::BaseType,
            MarketDataType::TradeBarType,
            MarketDataType::TickTypeType,
            MarketDataType::AuxiliaryType,
            MarketDataType::QuoteBarType,
            MarketDataType::OptionChainType,
            MarketDataType::FuturesChainType,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new_pb_name::<MarketDataType>("MarketDataType", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for MarketDataType {
}

impl ::std::default::Default for MarketDataType {
    fn default() -> Self {
        MarketDataType::BaseType
    }
}

impl ::protobuf::reflect::ProtobufValue for MarketDataType {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(self.descriptor())
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum OptionRight {
    Call = 0,
    Put = 1,
}

impl ::protobuf::ProtobufEnum for OptionRight {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<OptionRight> {
        match value {
            0 => ::std::option::Option::Some(OptionRight::Call),
            1 => ::std::option::Option::Some(OptionRight::Put),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [OptionRight] = &[
            OptionRight::Call,
            OptionRight::Put,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new_pb_name::<OptionRight>("OptionRight", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for OptionRight {
}

impl ::std::default::Default for OptionRight {
    fn default() -> Self {
        OptionRight::Call
    }
}

impl ::protobuf::reflect::ProtobufValue for OptionRight {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(self.descriptor())
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum OptionStyle {
    American = 0,
    European = 1,
}

impl ::protobuf::ProtobufEnum for OptionStyle {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<OptionStyle> {
        match value {
            0 => ::std::option::Option::Some(OptionStyle::American),
            1 => ::std::option::Option::Some(OptionStyle::European),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [OptionStyle] = &[
            OptionStyle::American,
            OptionStyle::European,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new_pb_name::<OptionStyle>("OptionStyle", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for OptionStyle {
}

impl ::std::default::Default for OptionStyle {
    fn default() -> Self {
        OptionStyle::American
    }
}

impl ::protobuf::reflect::ProtobufValue for OptionStyle {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(self.descriptor())
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum SecurityType {
    Base = 0,
    Equity = 1,
    Option = 2,
    Commodity = 3,
    Forex = 4,
    Future = 5,
    Cfd = 6,
    Crypto = 7,
}

impl ::protobuf::ProtobufEnum for SecurityType {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<SecurityType> {
        match value {
            0 => ::std::option::Option::Some(SecurityType::Base),
            1 => ::std::option::Option::Some(SecurityType::Equity),
            2 => ::std::option::Option::Some(SecurityType::Option),
            3 => ::std::option::Option::Some(SecurityType::Commodity),
            4 => ::std::option::Option::Some(SecurityType::Forex),
            5 => ::std::option::Option::Some(SecurityType::Future),
            6 => ::std::option::Option::Some(SecurityType::Cfd),
            7 => ::std::option::Option::Some(SecurityType::Crypto),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [SecurityType] = &[
            SecurityType::Base,
            SecurityType::Equity,
            SecurityType::Option,
            SecurityType::Commodity,
            SecurityType::Forex,
            SecurityType::Future,
            SecurityType::Cfd,
            SecurityType::Crypto,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new_pb_name::<SecurityType>("SecurityType", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for SecurityType {
}

impl ::std::default::Default for SecurityType {
    fn default() -> Self {
        SecurityType::Base
    }
}

impl ::protobuf::reflect::ProtobufValue for SecurityType {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(self.descriptor())
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum TickType {
    Trade = 0,
    Quote = 1,
    OpenInterest = 2,
}

impl ::protobuf::ProtobufEnum for TickType {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<TickType> {
        match value {
            0 => ::std::option::Option::Some(TickType::Trade),
            1 => ::std::option::Option::Some(TickType::Quote),
            2 => ::std::option::Option::Some(TickType::OpenInterest),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [TickType] = &[
            TickType::Trade,
            TickType::Quote,
            TickType::OpenInterest,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new_pb_name::<TickType>("TickType", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for TickType {
}

impl ::std::default::Default for TickType {
    fn default() -> Self {
        TickType::Trade
    }
}

impl ::protobuf::reflect::ProtobufValue for TickType {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(self.descriptor())
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n\x08qc.proto\x1a\tbcl.proto\"\xc1\x02\n\x08BaseData\x12+\n\x08DataType\
    \x18\x01\x20\x01(\x0e2\x0f.MarketDataTypeR\x08DataType\x12'\n\x07EndTime\
    \x18\x02\x20\x01(\x0b2\r.bcl.DateTimeR\x07EndTime\x12$\n\rIsFillForward\
    \x18\x03\x20\x01(\x08R\rIsFillForward\x12\x1f\n\x06Symbol\x18\x04\x20\
    \x01(\x0b2\x07.SymbolR\x06Symbol\x12!\n\x04Time\x18\x05\x20\x01(\x0b2\r.\
    bcl.DateTimeR\x04Time\x12\"\n\x05Value\x18\x06\x20\x01(\x0b2\x0c.bcl.Dec\
    imalR\x05Value\x12(\n\x08TradeBar\x18\xc8\x01\x20\x01(\x0b2\t.TradeBarH\
    \0R\x08TradeBar\x12\x1c\n\x04Tick\x18\xca\x01\x20\x01(\x0b2\x05.TickH\0R\
    \x04TickB\t\n\x07subtype\"0\n\rList_BaseData\x12\x1f\n\x05items\x18\x01\
    \x20\x03(\x0b2\t.BaseDataR\x05items\"\xff\x02\n\x12SecurityIdentifier\
    \x12\x17\n\x07_symbol\x18\x01\x20\x01(\tR\x06Symbol\x12\x1f\n\x0b_proper\
    ties\x18\x02\x20\x01(\x04R\nProperties\x12(\n\x0b_underlying\x18\x03\x20\
    \x01(\x0b2\x07.SidBoxR\nUnderlying\x12\x1b\n\t_hashCode\x18\x04\x20\x01(\
    \x05R\x08HashCode\x12/\n\x0c_strikePrice\x18\x05\x20\x01(\x0b2\x0c.bcl.D\
    ecimalR\x0bStrikePrice\x12/\n\x0c_optionStyle\x18\x06\x20\x01(\x0e2\x0c.\
    OptionStyleR\x0bOptionStyle\x12/\n\x0c_optionRight\x18\x07\x20\x01(\x0e2\
    \x0c.OptionRightR\x0bOptionRight\x12\"\n\x05_date\x18\x08\x20\x01(\x0b2\
    \r.bcl.DateTimeR\x04Date\x121\n\x0cSecurityType\x18\t\x20\x01(\x0e2\r.Se\
    curityTypeR\x0cSecurityType\"M\n\x06SidBox\x12C\n\x12SecurityIdentifier\
    \x18\x01\x20\x01(\x0b2\x13.SecurityIdentifierR\x12SecurityIdentifier\"\
    \xc5\x01\n\x06Symbol\x12$\n\rHasUnderlying\x18\x01\x20\x01(\x08R\rHasUnd\
    erlying\x12#\n\x02ID\x18\x02\x20\x01(\x0b2\x13.SecurityIdentifierR\x02ID\
    \x121\n\x0cSecurityType\x18\x03\x20\x01(\x0e2\r.SecurityTypeR\x0cSecurit\
    yType\x12'\n\nUnderlying\x18\x04\x20\x01(\x0b2\x07.SymbolR\nUnderlying\
    \x12\x14\n\x05Value\x18\x05\x20\x01(\tR\x05Value\"\xdd\x02\n\x04Tick\x12\
    (\n\x08AskPrice\x18\x01\x20\x01(\x0b2\x0c.bcl.DecimalR\x08AskPrice\x12&\
    \n\x07AskSize\x18\x02\x20\x01(\x0b2\x0c.bcl.DecimalR\x07AskSize\x12(\n\
    \x08BidPrice\x18\x03\x20\x01(\x0b2\x0c.bcl.DecimalR\x08BidPrice\x12&\n\
    \x07BidSize\x18\x04\x20\x01(\x0b2\x0c.bcl.DecimalR\x07BidSize\x12\x1a\n\
    \x08Exchange\x18\x05\x20\x01(\tR\x08Exchange\x12(\n\x08Quantity\x18\x06\
    \x20\x01(\x0b2\x0c.bcl.DecimalR\x08Quantity\x12$\n\rSaleCondition\x18\
    \x07\x20\x01(\tR\rSaleCondition\x12\x1e\n\nSuspicious\x18\x08\x20\x01(\
    \x08R\nSuspicious\x12%\n\x08TickType\x18\t\x20\x01(\x0e2\t.TickTypeR\x08\
    TickType\"\x88\x02\n\x08TradeBar\x12\"\n\x05Close\x18\x01\x20\x01(\x0b2\
    \x0c.bcl.DecimalR\x05Close\x12'\n\x07EndTime\x18\x02\x20\x01(\x0b2\r.bcl\
    .DateTimeR\x07EndTime\x12\x20\n\x04High\x18\x03\x20\x01(\x0b2\x0c.bcl.De\
    cimalR\x04High\x12\x1e\n\x03Low\x18\x04\x20\x01(\x0b2\x0c.bcl.DecimalR\
    \x03Low\x12\x20\n\x04Open\x18\x05\x20\x01(\x0b2\x0c.bcl.DecimalR\x04Open\
    \x12%\n\x06Period\x18\x06\x20\x01(\x0b2\r.bcl.TimeSpanR\x06Period\x12$\n\
    \x06Volume\x18\x07\x20\x01(\x0b2\x0c.bcl.DecimalR\x06Volume*\x92\x01\n\
    \x0eMarketDataType\x12\x0c\n\x08BaseType\x10\0\x12\x10\n\x0cTradeBarType\
    \x10\x01\x12\x10\n\x0cTickTypeType\x10\x02\x12\x11\n\rAuxiliaryType\x10\
    \x03\x12\x10\n\x0cQuoteBarType\x10\x04\x12\x13\n\x0fOptionChainType\x10\
    \x05\x12\x14\n\x10FuturesChainType\x10\x06*\x20\n\x0bOptionRight\x12\x08\
    \n\x04Call\x10\0\x12\x07\n\x03Put\x10\x01*)\n\x0bOptionStyle\x12\x0c\n\
    \x08American\x10\0\x12\x0c\n\x08European\x10\x01*k\n\x0cSecurityType\x12\
    \x08\n\x04Base\x10\0\x12\n\n\x06Equity\x10\x01\x12\n\n\x06Option\x10\x02\
    \x12\r\n\tCommodity\x10\x03\x12\t\n\x05Forex\x10\x04\x12\n\n\x06Future\
    \x10\x05\x12\x07\n\x03Cfd\x10\x06\x12\n\n\x06Crypto\x10\x07*2\n\x08TickT\
    ype\x12\t\n\x05Trade\x10\0\x12\t\n\x05Quote\x10\x01\x12\x10\n\x0cOpenInt\
    erest\x10\x02J\xbe\x1b\n\x06\x12\x04\0\0Z\x01\n\x08\n\x01\x0c\x12\x03\0\
    \0\x12\nB\n\x02\x03\0\x12\x03\x01\0\x13\"7\x20schema\x20for\x20protobuf-\
    net's\x20handling\x20of\x20core\x20.NET\x20types\n\n\n\n\x02\x04\0\x12\
    \x04\x03\0\x0e\x01\n\n\n\x03\x04\0\x01\x12\x03\x03\x08\x10\n\x0b\n\x04\
    \x04\0\x02\0\x12\x03\x04\x03\x1f\n\x0c\n\x05\x04\0\x02\0\x06\x12\x03\x04\
    \x03\x11\n\x0c\n\x05\x04\0\x02\0\x01\x12\x03\x04\x12\x1a\n\x0c\n\x05\x04\
    \0\x02\0\x03\x12\x03\x04\x1d\x1e\n\x0b\n\x04\x04\0\x02\x01\x12\x03\x05\
    \x03\x1d\n\x0c\n\x05\x04\0\x02\x01\x06\x12\x03\x05\x03\x10\n\x0c\n\x05\
    \x04\0\x02\x01\x01\x12\x03\x05\x11\x18\n\x0c\n\x05\x04\0\x02\x01\x03\x12\
    \x03\x05\x1b\x1c\n\x0b\n\x04\x04\0\x02\x02\x12\x03\x06\x03\x1a\n\x0c\n\
    \x05\x04\0\x02\x02\x05\x12\x03\x06\x03\x07\n\x0c\n\x05\x04\0\x02\x02\x01\
    \x12\x03\x06\x08\x15\n\x0c\n\x05\x04\0\x02\x02\x03\x12\x03\x06\x18\x19\n\
    \x0b\n\x04\x04\0\x02\x03\x12\x03\x07\x03\x15\n\x0c\n\x05\x04\0\x02\x03\
    \x06\x12\x03\x07\x03\t\n\x0c\n\x05\x04\0\x02\x03\x01\x12\x03\x07\n\x10\n\
    \x0c\n\x05\x04\0\x02\x03\x03\x12\x03\x07\x13\x14\n\x0b\n\x04\x04\0\x02\
    \x04\x12\x03\x08\x03\x1a\n\x0c\n\x05\x04\0\x02\x04\x06\x12\x03\x08\x03\
    \x10\n\x0c\n\x05\x04\0\x02\x04\x01\x12\x03\x08\x11\x15\n\x0c\n\x05\x04\0\
    \x02\x04\x03\x12\x03\x08\x18\x19\n\x0b\n\x04\x04\0\x02\x05\x12\x03\t\x03\
    \x1a\n\x0c\n\x05\x04\0\x02\x05\x06\x12\x03\t\x03\x0f\n\x0c\n\x05\x04\0\
    \x02\x05\x01\x12\x03\t\x10\x15\n\x0c\n\x05\x04\0\x02\x05\x03\x12\x03\t\
    \x18\x19\n\x0c\n\x04\x04\0\x08\0\x12\x04\n\x03\r\x04\n\x0c\n\x05\x04\0\
    \x08\0\x01\x12\x03\n\t\x10\n\x0b\n\x04\x04\0\x02\x06\x12\x03\x0b\x06\x1e\
    \n\x0c\n\x05\x04\0\x02\x06\x06\x12\x03\x0b\x06\x0e\n\x0c\n\x05\x04\0\x02\
    \x06\x01\x12\x03\x0b\x0f\x17\n\x0c\n\x05\x04\0\x02\x06\x03\x12\x03\x0b\
    \x1a\x1d\n\x0b\n\x04\x04\0\x02\x07\x12\x03\x0c\x06\x16\n\x0c\n\x05\x04\0\
    \x02\x07\x06\x12\x03\x0c\x06\n\n\x0c\n\x05\x04\0\x02\x07\x01\x12\x03\x0c\
    \x0b\x0f\n\x0c\n\x05\x04\0\x02\x07\x03\x12\x03\x0c\x12\x15\n\n\n\x02\x04\
    \x01\x12\x04\x0f\0\x11\x01\n\n\n\x03\x04\x01\x01\x12\x03\x0f\x08\x15\n\
    \x0b\n\x04\x04\x01\x02\0\x12\x03\x10\x03\x1f\n\x0c\n\x05\x04\x01\x02\0\
    \x04\x12\x03\x10\x03\x0b\n\x0c\n\x05\x04\x01\x02\0\x06\x12\x03\x10\x0c\
    \x14\n\x0c\n\x05\x04\x01\x02\0\x01\x12\x03\x10\x15\x1a\n\x0c\n\x05\x04\
    \x01\x02\0\x03\x12\x03\x10\x1d\x1e\n\n\n\x02\x05\0\x12\x04\x12\0\x1a\x01\
    \n\n\n\x03\x05\0\x01\x12\x03\x12\x05\x13\n\x0b\n\x04\x05\0\x02\0\x12\x03\
    \x13\x03\x10\n\x0c\n\x05\x05\0\x02\0\x01\x12\x03\x13\x03\x0b\n\x0c\n\x05\
    \x05\0\x02\0\x02\x12\x03\x13\x0e\x0f\n\x0b\n\x04\x05\0\x02\x01\x12\x03\
    \x14\x03\x14\n\x0c\n\x05\x05\0\x02\x01\x01\x12\x03\x14\x03\x0f\n\x0c\n\
    \x05\x05\0\x02\x01\x02\x12\x03\x14\x12\x13\n\x0b\n\x04\x05\0\x02\x02\x12\
    \x03\x15\x03\x14\n\x0c\n\x05\x05\0\x02\x02\x01\x12\x03\x15\x03\x0f\n\x0c\
    \n\x05\x05\0\x02\x02\x02\x12\x03\x15\x12\x13\n\x0b\n\x04\x05\0\x02\x03\
    \x12\x03\x16\x03\x15\n\x0c\n\x05\x05\0\x02\x03\x01\x12\x03\x16\x03\x10\n\
    \x0c\n\x05\x05\0\x02\x03\x02\x12\x03\x16\x13\x14\n\x0b\n\x04\x05\0\x02\
    \x04\x12\x03\x17\x03\x14\n\x0c\n\x05\x05\0\x02\x04\x01\x12\x03\x17\x03\
    \x0f\n\x0c\n\x05\x05\0\x02\x04\x02\x12\x03\x17\x12\x13\n\x0b\n\x04\x05\0\
    \x02\x05\x12\x03\x18\x03\x17\n\x0c\n\x05\x05\0\x02\x05\x01\x12\x03\x18\
    \x03\x12\n\x0c\n\x05\x05\0\x02\x05\x02\x12\x03\x18\x15\x16\n\x0b\n\x04\
    \x05\0\x02\x06\x12\x03\x19\x03\x18\n\x0c\n\x05\x05\0\x02\x06\x01\x12\x03\
    \x19\x03\x13\n\x0c\n\x05\x05\0\x02\x06\x02\x12\x03\x19\x16\x17\n\n\n\x02\
    \x05\x01\x12\x04\x1b\0\x1e\x01\n\n\n\x03\x05\x01\x01\x12\x03\x1b\x05\x10\
    \n\x0b\n\x04\x05\x01\x02\0\x12\x03\x1c\x03\x0c\n\x0c\n\x05\x05\x01\x02\0\
    \x01\x12\x03\x1c\x03\x07\n\x0c\n\x05\x05\x01\x02\0\x02\x12\x03\x1c\n\x0b\
    \n\x0b\n\x04\x05\x01\x02\x01\x12\x03\x1d\x03\x0b\n\x0c\n\x05\x05\x01\x02\
    \x01\x01\x12\x03\x1d\x03\x06\n\x0c\n\x05\x05\x01\x02\x01\x02\x12\x03\x1d\
    \t\n\n\n\n\x02\x05\x02\x12\x04\x1f\0\"\x01\n\n\n\x03\x05\x02\x01\x12\x03\
    \x1f\x05\x10\n\x0b\n\x04\x05\x02\x02\0\x12\x03\x20\x03\x10\n\x0c\n\x05\
    \x05\x02\x02\0\x01\x12\x03\x20\x03\x0b\n\x0c\n\x05\x05\x02\x02\0\x02\x12\
    \x03\x20\x0e\x0f\n\x0b\n\x04\x05\x02\x02\x01\x12\x03!\x03\x10\n\x0c\n\
    \x05\x05\x02\x02\x01\x01\x12\x03!\x03\x0b\n\x0c\n\x05\x05\x02\x02\x01\
    \x02\x12\x03!\x0e\x0f\n\n\n\x02\x04\x02\x12\x04#\0-\x01\n\n\n\x03\x04\
    \x02\x01\x12\x03#\x08\x1a\n\x0b\n\x04\x04\x02\x02\0\x12\x03$\x03\x16\n\
    \x0c\n\x05\x04\x02\x02\0\x05\x12\x03$\x03\t\n\x0c\n\x05\x04\x02\x02\0\
    \x01\x12\x03$\n\x11\n\x0c\n\x05\x04\x02\x02\0\x03\x12\x03$\x14\x15\n\x0b\
    \n\x04\x04\x02\x02\x01\x12\x03%\x03\x1a\n\x0c\n\x05\x04\x02\x02\x01\x05\
    \x12\x03%\x03\t\n\x0c\n\x05\x04\x02\x02\x01\x01\x12\x03%\n\x15\n\x0c\n\
    \x05\x04\x02\x02\x01\x03\x12\x03%\x18\x19\n\x0b\n\x04\x04\x02\x02\x02\
    \x12\x03&\x03\x1a\n\x0c\n\x05\x04\x02\x02\x02\x06\x12\x03&\x03\t\n\x0c\n\
    \x05\x04\x02\x02\x02\x01\x12\x03&\n\x15\n\x0c\n\x05\x04\x02\x02\x02\x03\
    \x12\x03&\x18\x19\n\x0b\n\x04\x04\x02\x02\x03\x12\x03'\x03\x17\n\x0c\n\
    \x05\x04\x02\x02\x03\x05\x12\x03'\x03\x08\n\x0c\n\x05\x04\x02\x02\x03\
    \x01\x12\x03'\t\x12\n\x0c\n\x05\x04\x02\x02\x03\x03\x12\x03'\x15\x16\n\
    \x0b\n\x04\x04\x02\x02\x04\x12\x03(\x03!\n\x0c\n\x05\x04\x02\x02\x04\x06\
    \x12\x03(\x03\x0f\n\x0c\n\x05\x04\x02\x02\x04\x01\x12\x03(\x10\x1c\n\x0c\
    \n\x05\x04\x02\x02\x04\x03\x12\x03(\x1f\x20\n\x0b\n\x04\x04\x02\x02\x05\
    \x12\x03)\x03\x20\n\x0c\n\x05\x04\x02\x02\x05\x06\x12\x03)\x03\x0e\n\x0c\
    \n\x05\x04\x02\x02\x05\x01\x12\x03)\x0f\x1b\n\x0c\n\x05\x04\x02\x02\x05\
    \x03\x12\x03)\x1e\x1f\n\x0b\n\x04\x04\x02\x02\x06\x12\x03*\x03\x20\n\x0c\
    \n\x05\x04\x02\x02\x06\x06\x12\x03*\x03\x0e\n\x0c\n\x05\x04\x02\x02\x06\
    \x01\x12\x03*\x0f\x1b\n\x0c\n\x05\x04\x02\x02\x06\x03\x12\x03*\x1e\x1f\n\
    \x0b\n\x04\x04\x02\x02\x07\x12\x03+\x03\x1b\n\x0c\n\x05\x04\x02\x02\x07\
    \x06\x12\x03+\x03\x10\n\x0c\n\x05\x04\x02\x02\x07\x01\x12\x03+\x11\x16\n\
    \x0c\n\x05\x04\x02\x02\x07\x03\x12\x03+\x19\x1a\n\x0b\n\x04\x04\x02\x02\
    \x08\x12\x03,\x03!\n\x0c\n\x05\x04\x02\x02\x08\x06\x12\x03,\x03\x0f\n\
    \x0c\n\x05\x04\x02\x02\x08\x01\x12\x03,\x10\x1c\n\x0c\n\x05\x04\x02\x02\
    \x08\x03\x12\x03,\x1f\x20\n\n\n\x02\x05\x03\x12\x04.\07\x01\n\n\n\x03\
    \x05\x03\x01\x12\x03.\x05\x11\n\x0b\n\x04\x05\x03\x02\0\x12\x03/\x03\x0c\
    \n\x0c\n\x05\x05\x03\x02\0\x01\x12\x03/\x03\x07\n\x0c\n\x05\x05\x03\x02\
    \0\x02\x12\x03/\n\x0b\n\x0b\n\x04\x05\x03\x02\x01\x12\x030\x03\x0e\n\x0c\
    \n\x05\x05\x03\x02\x01\x01\x12\x030\x03\t\n\x0c\n\x05\x05\x03\x02\x01\
    \x02\x12\x030\x0c\r\n\x0b\n\x04\x05\x03\x02\x02\x12\x031\x03\x0e\n\x0c\n\
    \x05\x05\x03\x02\x02\x01\x12\x031\x03\t\n\x0c\n\x05\x05\x03\x02\x02\x02\
    \x12\x031\x0c\r\n\x0b\n\x04\x05\x03\x02\x03\x12\x032\x03\x11\n\x0c\n\x05\
    \x05\x03\x02\x03\x01\x12\x032\x03\x0c\n\x0c\n\x05\x05\x03\x02\x03\x02\
    \x12\x032\x0f\x10\n\x0b\n\x04\x05\x03\x02\x04\x12\x033\x03\r\n\x0c\n\x05\
    \x05\x03\x02\x04\x01\x12\x033\x03\x08\n\x0c\n\x05\x05\x03\x02\x04\x02\
    \x12\x033\x0b\x0c\n\x0b\n\x04\x05\x03\x02\x05\x12\x034\x03\x0e\n\x0c\n\
    \x05\x05\x03\x02\x05\x01\x12\x034\x03\t\n\x0c\n\x05\x05\x03\x02\x05\x02\
    \x12\x034\x0c\r\n\x0b\n\x04\x05\x03\x02\x06\x12\x035\x03\x0b\n\x0c\n\x05\
    \x05\x03\x02\x06\x01\x12\x035\x03\x06\n\x0c\n\x05\x05\x03\x02\x06\x02\
    \x12\x035\t\n\n\x0b\n\x04\x05\x03\x02\x07\x12\x036\x03\x0e\n\x0c\n\x05\
    \x05\x03\x02\x07\x01\x12\x036\x03\t\n\x0c\n\x05\x05\x03\x02\x07\x02\x12\
    \x036\x0c\r\n\n\n\x02\x04\x03\x12\x048\0:\x01\n\n\n\x03\x04\x03\x01\x12\
    \x038\x08\x0e\n\x0b\n\x04\x04\x03\x02\0\x12\x039\x03-\n\x0c\n\x05\x04\
    \x03\x02\0\x06\x12\x039\x03\x15\n\x0c\n\x05\x04\x03\x02\0\x01\x12\x039\
    \x16(\n\x0c\n\x05\x04\x03\x02\0\x03\x12\x039+,\n\n\n\x02\x04\x04\x12\x04\
    ;\0A\x01\n\n\n\x03\x04\x04\x01\x12\x03;\x08\x0e\n\x0b\n\x04\x04\x04\x02\
    \0\x12\x03<\x03\x1a\n\x0c\n\x05\x04\x04\x02\0\x05\x12\x03<\x03\x07\n\x0c\
    \n\x05\x04\x04\x02\0\x01\x12\x03<\x08\x15\n\x0c\n\x05\x04\x04\x02\0\x03\
    \x12\x03<\x18\x19\n\x0b\n\x04\x04\x04\x02\x01\x12\x03=\x03\x1d\n\x0c\n\
    \x05\x04\x04\x02\x01\x06\x12\x03=\x03\x15\n\x0c\n\x05\x04\x04\x02\x01\
    \x01\x12\x03=\x16\x18\n\x0c\n\x05\x04\x04\x02\x01\x03\x12\x03=\x1b\x1c\n\
    \x0b\n\x04\x04\x04\x02\x02\x12\x03>\x03!\n\x0c\n\x05\x04\x04\x02\x02\x06\
    \x12\x03>\x03\x0f\n\x0c\n\x05\x04\x04\x02\x02\x01\x12\x03>\x10\x1c\n\x0c\
    \n\x05\x04\x04\x02\x02\x03\x12\x03>\x1f\x20\n\x0b\n\x04\x04\x04\x02\x03\
    \x12\x03?\x03\x19\n\x0c\n\x05\x04\x04\x02\x03\x06\x12\x03?\x03\t\n\x0c\n\
    \x05\x04\x04\x02\x03\x01\x12\x03?\n\x14\n\x0c\n\x05\x04\x04\x02\x03\x03\
    \x12\x03?\x17\x18\n\x0b\n\x04\x04\x04\x02\x04\x12\x03@\x03\x14\n\x0c\n\
    \x05\x04\x04\x02\x04\x05\x12\x03@\x03\t\n\x0c\n\x05\x04\x04\x02\x04\x01\
    \x12\x03@\n\x0f\n\x0c\n\x05\x04\x04\x02\x04\x03\x12\x03@\x12\x13\n\n\n\
    \x02\x04\x05\x12\x04B\0L\x01\n\n\n\x03\x04\x05\x01\x12\x03B\x08\x0c\n\
    \x0b\n\x04\x04\x05\x02\0\x12\x03C\x03\x1d\n\x0c\n\x05\x04\x05\x02\0\x06\
    \x12\x03C\x03\x0f\n\x0c\n\x05\x04\x05\x02\0\x01\x12\x03C\x10\x18\n\x0c\n\
    \x05\x04\x05\x02\0\x03\x12\x03C\x1b\x1c\n\x0b\n\x04\x04\x05\x02\x01\x12\
    \x03D\x03\x1c\n\x0c\n\x05\x04\x05\x02\x01\x06\x12\x03D\x03\x0f\n\x0c\n\
    \x05\x04\x05\x02\x01\x01\x12\x03D\x10\x17\n\x0c\n\x05\x04\x05\x02\x01\
    \x03\x12\x03D\x1a\x1b\n\x0b\n\x04\x04\x05\x02\x02\x12\x03E\x03\x1d\n\x0c\
    \n\x05\x04\x05\x02\x02\x06\x12\x03E\x03\x0f\n\x0c\n\x05\x04\x05\x02\x02\
    \x01\x12\x03E\x10\x18\n\x0c\n\x05\x04\x05\x02\x02\x03\x12\x03E\x1b\x1c\n\
    \x0b\n\x04\x04\x05\x02\x03\x12\x03F\x03\x1c\n\x0c\n\x05\x04\x05\x02\x03\
    \x06\x12\x03F\x03\x0f\n\x0c\n\x05\x04\x05\x02\x03\x01\x12\x03F\x10\x17\n\
    \x0c\n\x05\x04\x05\x02\x03\x03\x12\x03F\x1a\x1b\n\x0b\n\x04\x04\x05\x02\
    \x04\x12\x03G\x03\x17\n\x0c\n\x05\x04\x05\x02\x04\x05\x12\x03G\x03\t\n\
    \x0c\n\x05\x04\x05\x02\x04\x01\x12\x03G\n\x12\n\x0c\n\x05\x04\x05\x02\
    \x04\x03\x12\x03G\x15\x16\n\x0b\n\x04\x04\x05\x02\x05\x12\x03H\x03\x1d\n\
    \x0c\n\x05\x04\x05\x02\x05\x06\x12\x03H\x03\x0f\n\x0c\n\x05\x04\x05\x02\
    \x05\x01\x12\x03H\x10\x18\n\x0c\n\x05\x04\x05\x02\x05\x03\x12\x03H\x1b\
    \x1c\n\x0b\n\x04\x04\x05\x02\x06\x12\x03I\x03\x1c\n\x0c\n\x05\x04\x05\
    \x02\x06\x05\x12\x03I\x03\t\n\x0c\n\x05\x04\x05\x02\x06\x01\x12\x03I\n\
    \x17\n\x0c\n\x05\x04\x05\x02\x06\x03\x12\x03I\x1a\x1b\n\x0b\n\x04\x04\
    \x05\x02\x07\x12\x03J\x03\x17\n\x0c\n\x05\x04\x05\x02\x07\x05\x12\x03J\
    \x03\x07\n\x0c\n\x05\x04\x05\x02\x07\x01\x12\x03J\x08\x12\n\x0c\n\x05\
    \x04\x05\x02\x07\x03\x12\x03J\x15\x16\n\x0b\n\x04\x04\x05\x02\x08\x12\
    \x03K\x03\x19\n\x0c\n\x05\x04\x05\x02\x08\x06\x12\x03K\x03\x0b\n\x0c\n\
    \x05\x04\x05\x02\x08\x01\x12\x03K\x0c\x14\n\x0c\n\x05\x04\x05\x02\x08\
    \x03\x12\x03K\x17\x18\n\n\n\x02\x05\x04\x12\x04M\0Q\x01\n\n\n\x03\x05\
    \x04\x01\x12\x03M\x05\r\n\x0b\n\x04\x05\x04\x02\0\x12\x03N\x03\r\n\x0c\n\
    \x05\x05\x04\x02\0\x01\x12\x03N\x03\x08\n\x0c\n\x05\x05\x04\x02\0\x02\
    \x12\x03N\x0b\x0c\n\x0b\n\x04\x05\x04\x02\x01\x12\x03O\x03\r\n\x0c\n\x05\
    \x05\x04\x02\x01\x01\x12\x03O\x03\x08\n\x0c\n\x05\x05\x04\x02\x01\x02\
    \x12\x03O\x0b\x0c\n\x0b\n\x04\x05\x04\x02\x02\x12\x03P\x03\x14\n\x0c\n\
    \x05\x05\x04\x02\x02\x01\x12\x03P\x03\x0f\n\x0c\n\x05\x05\x04\x02\x02\
    \x02\x12\x03P\x12\x13\n\n\n\x02\x04\x06\x12\x04R\0Z\x01\n\n\n\x03\x04\
    \x06\x01\x12\x03R\x08\x10\n\x0b\n\x04\x04\x06\x02\0\x12\x03S\x03\x1a\n\
    \x0c\n\x05\x04\x06\x02\0\x06\x12\x03S\x03\x0f\n\x0c\n\x05\x04\x06\x02\0\
    \x01\x12\x03S\x10\x15\n\x0c\n\x05\x04\x06\x02\0\x03\x12\x03S\x18\x19\n\
    \x0b\n\x04\x04\x06\x02\x01\x12\x03T\x03\x1d\n\x0c\n\x05\x04\x06\x02\x01\
    \x06\x12\x03T\x03\x10\n\x0c\n\x05\x04\x06\x02\x01\x01\x12\x03T\x11\x18\n\
    \x0c\n\x05\x04\x06\x02\x01\x03\x12\x03T\x1b\x1c\n\x0b\n\x04\x04\x06\x02\
    \x02\x12\x03U\x03\x19\n\x0c\n\x05\x04\x06\x02\x02\x06\x12\x03U\x03\x0f\n\
    \x0c\n\x05\x04\x06\x02\x02\x01\x12\x03U\x10\x14\n\x0c\n\x05\x04\x06\x02\
    \x02\x03\x12\x03U\x17\x18\n\x0b\n\x04\x04\x06\x02\x03\x12\x03V\x03\x18\n\
    \x0c\n\x05\x04\x06\x02\x03\x06\x12\x03V\x03\x0f\n\x0c\n\x05\x04\x06\x02\
    \x03\x01\x12\x03V\x10\x13\n\x0c\n\x05\x04\x06\x02\x03\x03\x12\x03V\x16\
    \x17\n\x0b\n\x04\x04\x06\x02\x04\x12\x03W\x03\x19\n\x0c\n\x05\x04\x06\
    \x02\x04\x06\x12\x03W\x03\x0f\n\x0c\n\x05\x04\x06\x02\x04\x01\x12\x03W\
    \x10\x14\n\x0c\n\x05\x04\x06\x02\x04\x03\x12\x03W\x17\x18\n\x0b\n\x04\
    \x04\x06\x02\x05\x12\x03X\x03\x1c\n\x0c\n\x05\x04\x06\x02\x05\x06\x12\
    \x03X\x03\x10\n\x0c\n\x05\x04\x06\x02\x05\x01\x12\x03X\x11\x17\n\x0c\n\
    \x05\x04\x06\x02\x05\x03\x12\x03X\x1a\x1b\n\x0b\n\x04\x04\x06\x02\x06\
    \x12\x03Y\x03\x1b\n\x0c\n\x05\x04\x06\x02\x06\x06\x12\x03Y\x03\x0f\n\x0c\
    \n\x05\x04\x06\x02\x06\x01\x12\x03Y\x10\x16\n\x0c\n\x05\x04\x06\x02\x06\
    \x03\x12\x03Y\x19\x1ab\x06proto3\
";

static mut file_descriptor_proto_lazy: ::protobuf::lazy::Lazy<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::lazy::Lazy::INIT;

fn parse_descriptor_proto() -> ::protobuf::descriptor::FileDescriptorProto {
    ::protobuf::parse_from_bytes(file_descriptor_proto_data).unwrap()
}

pub fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    unsafe {
        file_descriptor_proto_lazy.get(|| {
            parse_descriptor_proto()
        })
    }
}
