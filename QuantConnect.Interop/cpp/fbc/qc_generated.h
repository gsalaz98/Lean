// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_QC_H_
#define FLATBUFFERS_GENERATED_QC_H_

#include "flatbuffers/flatbuffers.h"

struct BaseDataCollection;
struct BaseDataCollectionBuilder;

struct SecurityIdentifier;
struct SecurityIdentifierBuilder;

struct SidBox;
struct SidBoxBuilder;

struct QCSymbol;
struct QCSymbolBuilder;

struct Tick;
struct TickBuilder;

struct TradeBar;
struct TradeBarBuilder;

enum MarketDataType {
  MarketDataType_Base = 0,
  MarketDataType_TradeBar = 1,
  MarketDataType_Tick = 2,
  MarketDataType_Auxiliary = 3,
  MarketDataType_QuoteBar = 4,
  MarketDataType_OptionChain = 5,
  MarketDataType_FuturesChain = 6,
  MarketDataType_MIN = MarketDataType_Base,
  MarketDataType_MAX = MarketDataType_FuturesChain
};

inline const MarketDataType (&EnumValuesMarketDataType())[7] {
  static const MarketDataType values[] = {
    MarketDataType_Base,
    MarketDataType_TradeBar,
    MarketDataType_Tick,
    MarketDataType_Auxiliary,
    MarketDataType_QuoteBar,
    MarketDataType_OptionChain,
    MarketDataType_FuturesChain
  };
  return values;
}

inline const char * const *EnumNamesMarketDataType() {
  static const char * const names[8] = {
    "Base",
    "TradeBar",
    "Tick",
    "Auxiliary",
    "QuoteBar",
    "OptionChain",
    "FuturesChain",
    nullptr
  };
  return names;
}

inline const char *EnumNameMarketDataType(MarketDataType e) {
  if (flatbuffers::IsOutRange(e, MarketDataType_Base, MarketDataType_FuturesChain)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesMarketDataType()[index];
}

enum OptionRight {
  OptionRight_Call = 0,
  OptionRight_Put = 1,
  OptionRight_MIN = OptionRight_Call,
  OptionRight_MAX = OptionRight_Put
};

inline const OptionRight (&EnumValuesOptionRight())[2] {
  static const OptionRight values[] = {
    OptionRight_Call,
    OptionRight_Put
  };
  return values;
}

inline const char * const *EnumNamesOptionRight() {
  static const char * const names[3] = {
    "Call",
    "Put",
    nullptr
  };
  return names;
}

inline const char *EnumNameOptionRight(OptionRight e) {
  if (flatbuffers::IsOutRange(e, OptionRight_Call, OptionRight_Put)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesOptionRight()[index];
}

enum OptionStyle {
  OptionStyle_American = 0,
  OptionStyle_European = 1,
  OptionStyle_MIN = OptionStyle_American,
  OptionStyle_MAX = OptionStyle_European
};

inline const OptionStyle (&EnumValuesOptionStyle())[2] {
  static const OptionStyle values[] = {
    OptionStyle_American,
    OptionStyle_European
  };
  return values;
}

inline const char * const *EnumNamesOptionStyle() {
  static const char * const names[3] = {
    "American",
    "European",
    nullptr
  };
  return names;
}

inline const char *EnumNameOptionStyle(OptionStyle e) {
  if (flatbuffers::IsOutRange(e, OptionStyle_American, OptionStyle_European)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesOptionStyle()[index];
}

enum SecurityType {
  SecurityType_Base = 0,
  SecurityType_Equity = 1,
  SecurityType_Option = 2,
  SecurityType_Commodity = 3,
  SecurityType_Forex = 4,
  SecurityType_Future = 5,
  SecurityType_Cfd = 6,
  SecurityType_Crypto = 7,
  SecurityType_MIN = SecurityType_Base,
  SecurityType_MAX = SecurityType_Crypto
};

inline const SecurityType (&EnumValuesSecurityType())[8] {
  static const SecurityType values[] = {
    SecurityType_Base,
    SecurityType_Equity,
    SecurityType_Option,
    SecurityType_Commodity,
    SecurityType_Forex,
    SecurityType_Future,
    SecurityType_Cfd,
    SecurityType_Crypto
  };
  return values;
}

inline const char * const *EnumNamesSecurityType() {
  static const char * const names[9] = {
    "Base",
    "Equity",
    "Option",
    "Commodity",
    "Forex",
    "Future",
    "Cfd",
    "Crypto",
    nullptr
  };
  return names;
}

inline const char *EnumNameSecurityType(SecurityType e) {
  if (flatbuffers::IsOutRange(e, SecurityType_Base, SecurityType_Crypto)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesSecurityType()[index];
}

enum TickType {
  TickType_Trade = 0,
  TickType_Quote = 1,
  TickType_OpenInterest = 2,
  TickType_MIN = TickType_Trade,
  TickType_MAX = TickType_OpenInterest
};

inline const TickType (&EnumValuesTickType())[3] {
  static const TickType values[] = {
    TickType_Trade,
    TickType_Quote,
    TickType_OpenInterest
  };
  return values;
}

inline const char * const *EnumNamesTickType() {
  static const char * const names[4] = {
    "Trade",
    "Quote",
    "OpenInterest",
    nullptr
  };
  return names;
}

inline const char *EnumNameTickType(TickType e) {
  if (flatbuffers::IsOutRange(e, TickType_Trade, TickType_OpenInterest)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesTickType()[index];
}

struct BaseDataCollection FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef BaseDataCollectionBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TICKS = 4,
    VT_TRADEBARS = 6
  };
  const flatbuffers::Vector<flatbuffers::Offset<Tick>> *Ticks() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<Tick>> *>(VT_TICKS);
  }
  const flatbuffers::Vector<flatbuffers::Offset<TradeBar>> *TradeBars() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<TradeBar>> *>(VT_TRADEBARS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_TICKS) &&
           verifier.VerifyVector(Ticks()) &&
           verifier.VerifyVectorOfTables(Ticks()) &&
           VerifyOffset(verifier, VT_TRADEBARS) &&
           verifier.VerifyVector(TradeBars()) &&
           verifier.VerifyVectorOfTables(TradeBars()) &&
           verifier.EndTable();
  }
};

struct BaseDataCollectionBuilder {
  typedef BaseDataCollection Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_Ticks(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Tick>>> Ticks) {
    fbb_.AddOffset(BaseDataCollection::VT_TICKS, Ticks);
  }
  void add_TradeBars(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<TradeBar>>> TradeBars) {
    fbb_.AddOffset(BaseDataCollection::VT_TRADEBARS, TradeBars);
  }
  explicit BaseDataCollectionBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  BaseDataCollectionBuilder &operator=(const BaseDataCollectionBuilder &);
  flatbuffers::Offset<BaseDataCollection> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<BaseDataCollection>(end);
    return o;
  }
};

inline flatbuffers::Offset<BaseDataCollection> CreateBaseDataCollection(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Tick>>> Ticks = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<TradeBar>>> TradeBars = 0) {
  BaseDataCollectionBuilder builder_(_fbb);
  builder_.add_TradeBars(TradeBars);
  builder_.add_Ticks(Ticks);
  return builder_.Finish();
}

inline flatbuffers::Offset<BaseDataCollection> CreateBaseDataCollectionDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<flatbuffers::Offset<Tick>> *Ticks = nullptr,
    const std::vector<flatbuffers::Offset<TradeBar>> *TradeBars = nullptr) {
  auto Ticks__ = Ticks ? _fbb.CreateVector<flatbuffers::Offset<Tick>>(*Ticks) : 0;
  auto TradeBars__ = TradeBars ? _fbb.CreateVector<flatbuffers::Offset<TradeBar>>(*TradeBars) : 0;
  return CreateBaseDataCollection(
      _fbb,
      Ticks__,
      TradeBars__);
}

struct SecurityIdentifier FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef SecurityIdentifierBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT__SYMBOL = 4,
    VT__PROPERTIES = 6,
    VT__UNDERLYING = 8,
    VT__HASHCODE = 10,
    VT__STRIKEPRICE = 12,
    VT__OPTIONSTYLE = 14,
    VT__OPTIONRIGHT = 16,
    VT__DATE = 18,
    VT_SECURITYTYPE = 20
  };
  const flatbuffers::String *_symbol() const {
    return GetPointer<const flatbuffers::String *>(VT__SYMBOL);
  }
  uint64_t _properties() const {
    return GetField<uint64_t>(VT__PROPERTIES, 0);
  }
  const SidBox *_underlying() const {
    return GetPointer<const SidBox *>(VT__UNDERLYING);
  }
  int32_t _hashCode() const {
    return GetField<int32_t>(VT__HASHCODE, 0);
  }
  double _strikePrice() const {
    return GetField<double>(VT__STRIKEPRICE, 0.0);
  }
  OptionStyle _optionStyle() const {
    return static_cast<OptionStyle>(GetField<int32_t>(VT__OPTIONSTYLE, 0));
  }
  OptionRight _optionRight() const {
    return static_cast<OptionRight>(GetField<int32_t>(VT__OPTIONRIGHT, 0));
  }
  int64_t _date() const {
    return GetField<int64_t>(VT__DATE, 0);
  }
  SecurityType SecurityType() const {
    return static_cast<::SecurityType>(GetField<int32_t>(VT_SECURITYTYPE, 0));
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT__SYMBOL) &&
           verifier.VerifyString(_symbol()) &&
           VerifyField<uint64_t>(verifier, VT__PROPERTIES) &&
           VerifyOffset(verifier, VT__UNDERLYING) &&
           verifier.VerifyTable(_underlying()) &&
           VerifyField<int32_t>(verifier, VT__HASHCODE) &&
           VerifyField<double>(verifier, VT__STRIKEPRICE) &&
           VerifyField<int32_t>(verifier, VT__OPTIONSTYLE) &&
           VerifyField<int32_t>(verifier, VT__OPTIONRIGHT) &&
           VerifyField<int64_t>(verifier, VT__DATE) &&
           VerifyField<int32_t>(verifier, VT_SECURITYTYPE) &&
           verifier.EndTable();
  }
};

struct SecurityIdentifierBuilder {
  typedef SecurityIdentifier Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add__symbol(flatbuffers::Offset<flatbuffers::String> _symbol) {
    fbb_.AddOffset(SecurityIdentifier::VT__SYMBOL, _symbol);
  }
  void add__properties(uint64_t _properties) {
    fbb_.AddElement<uint64_t>(SecurityIdentifier::VT__PROPERTIES, _properties, 0);
  }
  void add__underlying(flatbuffers::Offset<SidBox> _underlying) {
    fbb_.AddOffset(SecurityIdentifier::VT__UNDERLYING, _underlying);
  }
  void add__hashCode(int32_t _hashCode) {
    fbb_.AddElement<int32_t>(SecurityIdentifier::VT__HASHCODE, _hashCode, 0);
  }
  void add__strikePrice(double _strikePrice) {
    fbb_.AddElement<double>(SecurityIdentifier::VT__STRIKEPRICE, _strikePrice, 0.0);
  }
  void add__optionStyle(OptionStyle _optionStyle) {
    fbb_.AddElement<int32_t>(SecurityIdentifier::VT__OPTIONSTYLE, static_cast<int32_t>(_optionStyle), 0);
  }
  void add__optionRight(OptionRight _optionRight) {
    fbb_.AddElement<int32_t>(SecurityIdentifier::VT__OPTIONRIGHT, static_cast<int32_t>(_optionRight), 0);
  }
  void add__date(int64_t _date) {
    fbb_.AddElement<int64_t>(SecurityIdentifier::VT__DATE, _date, 0);
  }
  void add_SecurityType(SecurityType SecurityType) {
    fbb_.AddElement<int32_t>(SecurityIdentifier::VT_SECURITYTYPE, static_cast<int32_t>(SecurityType), 0);
  }
  explicit SecurityIdentifierBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  SecurityIdentifierBuilder &operator=(const SecurityIdentifierBuilder &);
  flatbuffers::Offset<SecurityIdentifier> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<SecurityIdentifier>(end);
    return o;
  }
};

inline flatbuffers::Offset<SecurityIdentifier> CreateSecurityIdentifier(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> _symbol = 0,
    uint64_t _properties = 0,
    flatbuffers::Offset<SidBox> _underlying = 0,
    int32_t _hashCode = 0,
    double _strikePrice = 0.0,
    OptionStyle _optionStyle = OptionStyle_American,
    OptionRight _optionRight = OptionRight_Call,
    int64_t _date = 0,
    SecurityType SecurityType = SecurityType_Base) {
  SecurityIdentifierBuilder builder_(_fbb);
  builder_.add__date(_date);
  builder_.add__strikePrice(_strikePrice);
  builder_.add__properties(_properties);
  builder_.add_SecurityType(SecurityType);
  builder_.add__optionRight(_optionRight);
  builder_.add__optionStyle(_optionStyle);
  builder_.add__hashCode(_hashCode);
  builder_.add__underlying(_underlying);
  builder_.add__symbol(_symbol);
  return builder_.Finish();
}

inline flatbuffers::Offset<SecurityIdentifier> CreateSecurityIdentifierDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *_symbol = nullptr,
    uint64_t _properties = 0,
    flatbuffers::Offset<SidBox> _underlying = 0,
    int32_t _hashCode = 0,
    double _strikePrice = 0.0,
    OptionStyle _optionStyle = OptionStyle_American,
    OptionRight _optionRight = OptionRight_Call,
    int64_t _date = 0,
    SecurityType SecurityType = SecurityType_Base) {
  auto _symbol__ = _symbol ? _fbb.CreateString(_symbol) : 0;
  return CreateSecurityIdentifier(
      _fbb,
      _symbol__,
      _properties,
      _underlying,
      _hashCode,
      _strikePrice,
      _optionStyle,
      _optionRight,
      _date,
      SecurityType);
}

struct SidBox FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef SidBoxBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_SECURITYIDENTIFIERINNER = 4
  };
  const SecurityIdentifier *SecurityIdentifierInner() const {
    return GetPointer<const SecurityIdentifier *>(VT_SECURITYIDENTIFIERINNER);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_SECURITYIDENTIFIERINNER) &&
           verifier.VerifyTable(SecurityIdentifierInner()) &&
           verifier.EndTable();
  }
};

struct SidBoxBuilder {
  typedef SidBox Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_SecurityIdentifierInner(flatbuffers::Offset<SecurityIdentifier> SecurityIdentifierInner) {
    fbb_.AddOffset(SidBox::VT_SECURITYIDENTIFIERINNER, SecurityIdentifierInner);
  }
  explicit SidBoxBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  SidBoxBuilder &operator=(const SidBoxBuilder &);
  flatbuffers::Offset<SidBox> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<SidBox>(end);
    return o;
  }
};

inline flatbuffers::Offset<SidBox> CreateSidBox(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<SecurityIdentifier> SecurityIdentifierInner = 0) {
  SidBoxBuilder builder_(_fbb);
  builder_.add_SecurityIdentifierInner(SecurityIdentifierInner);
  return builder_.Finish();
}

struct QCSymbol FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef QCSymbolBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_HASUNDERLYING = 4,
    VT_ID = 6,
    VT_SECURITYTYPE = 8,
    VT_UNDERLYING = 10,
    VT_VALUE = 12
  };
  bool HasUnderlying() const {
    return GetField<uint8_t>(VT_HASUNDERLYING, 0) != 0;
  }
  const SecurityIdentifier *ID() const {
    return GetPointer<const SecurityIdentifier *>(VT_ID);
  }
  SecurityType SecurityType() const {
    return static_cast<::SecurityType>(GetField<int32_t>(VT_SECURITYTYPE, 0));
  }
  const QCSymbol *Underlying() const {
    return GetPointer<const QCSymbol *>(VT_UNDERLYING);
  }
  const flatbuffers::String *Value() const {
    return GetPointer<const flatbuffers::String *>(VT_VALUE);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_HASUNDERLYING) &&
           VerifyOffset(verifier, VT_ID) &&
           verifier.VerifyTable(ID()) &&
           VerifyField<int32_t>(verifier, VT_SECURITYTYPE) &&
           VerifyOffset(verifier, VT_UNDERLYING) &&
           verifier.VerifyTable(Underlying()) &&
           VerifyOffset(verifier, VT_VALUE) &&
           verifier.VerifyString(Value()) &&
           verifier.EndTable();
  }
};

struct QCSymbolBuilder {
  typedef QCSymbol Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_HasUnderlying(bool HasUnderlying) {
    fbb_.AddElement<uint8_t>(QCSymbol::VT_HASUNDERLYING, static_cast<uint8_t>(HasUnderlying), 0);
  }
  void add_ID(flatbuffers::Offset<SecurityIdentifier> ID) {
    fbb_.AddOffset(QCSymbol::VT_ID, ID);
  }
  void add_SecurityType(SecurityType SecurityType) {
    fbb_.AddElement<int32_t>(QCSymbol::VT_SECURITYTYPE, static_cast<int32_t>(SecurityType), 0);
  }
  void add_Underlying(flatbuffers::Offset<QCSymbol> Underlying) {
    fbb_.AddOffset(QCSymbol::VT_UNDERLYING, Underlying);
  }
  void add_Value(flatbuffers::Offset<flatbuffers::String> Value) {
    fbb_.AddOffset(QCSymbol::VT_VALUE, Value);
  }
  explicit QCSymbolBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  QCSymbolBuilder &operator=(const QCSymbolBuilder &);
  flatbuffers::Offset<QCSymbol> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<QCSymbol>(end);
    return o;
  }
};

inline flatbuffers::Offset<QCSymbol> CreateQCSymbol(
    flatbuffers::FlatBufferBuilder &_fbb,
    bool HasUnderlying = false,
    flatbuffers::Offset<SecurityIdentifier> ID = 0,
    SecurityType SecurityType = SecurityType_Base,
    flatbuffers::Offset<QCSymbol> Underlying = 0,
    flatbuffers::Offset<flatbuffers::String> Value = 0) {
  QCSymbolBuilder builder_(_fbb);
  builder_.add_Value(Value);
  builder_.add_Underlying(Underlying);
  builder_.add_SecurityType(SecurityType);
  builder_.add_ID(ID);
  builder_.add_HasUnderlying(HasUnderlying);
  return builder_.Finish();
}

inline flatbuffers::Offset<QCSymbol> CreateQCSymbolDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    bool HasUnderlying = false,
    flatbuffers::Offset<SecurityIdentifier> ID = 0,
    SecurityType SecurityType = SecurityType_Base,
    flatbuffers::Offset<QCSymbol> Underlying = 0,
    const char *Value = nullptr) {
  auto Value__ = Value ? _fbb.CreateString(Value) : 0;
  return CreateQCSymbol(
      _fbb,
      HasUnderlying,
      ID,
      SecurityType,
      Underlying,
      Value__);
}

struct Tick FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef TickBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_DATATYPE = 4,
    VT_ENDTIME = 6,
    VT_ISFILLFORWARD = 8,
    VT_SYMBOL = 10,
    VT_TIME = 12,
    VT_VALUE = 14,
    VT_ASKPRICE = 16,
    VT_ASKSIZE = 18,
    VT_BIDPRICE = 20,
    VT_BIDSIZE = 22,
    VT_EXCHANGE = 24,
    VT_QUANTITY = 26,
    VT_SALECONDITION = 28,
    VT_SUSPICIOUS = 30,
    VT_TICKTYPE = 32
  };
  MarketDataType DataType() const {
    return static_cast<MarketDataType>(GetField<int32_t>(VT_DATATYPE, 0));
  }
  int64_t EndTime() const {
    return GetField<int64_t>(VT_ENDTIME, 0);
  }
  bool IsFillForward() const {
    return GetField<uint8_t>(VT_ISFILLFORWARD, 0) != 0;
  }
  const QCSymbol *Symbol() const {
    return GetPointer<const QCSymbol *>(VT_SYMBOL);
  }
  int64_t Time() const {
    return GetField<int64_t>(VT_TIME, 0);
  }
  double Value() const {
    return GetField<double>(VT_VALUE, 0.0);
  }
  double AskPrice() const {
    return GetField<double>(VT_ASKPRICE, 0.0);
  }
  double AskSize() const {
    return GetField<double>(VT_ASKSIZE, 0.0);
  }
  double BidPrice() const {
    return GetField<double>(VT_BIDPRICE, 0.0);
  }
  double BidSize() const {
    return GetField<double>(VT_BIDSIZE, 0.0);
  }
  const flatbuffers::String *Exchange() const {
    return GetPointer<const flatbuffers::String *>(VT_EXCHANGE);
  }
  double Quantity() const {
    return GetField<double>(VT_QUANTITY, 0.0);
  }
  const flatbuffers::String *SaleCondition() const {
    return GetPointer<const flatbuffers::String *>(VT_SALECONDITION);
  }
  bool Suspicious() const {
    return GetField<uint8_t>(VT_SUSPICIOUS, 0) != 0;
  }
  TickType TickType() const {
    return static_cast<::TickType>(GetField<int32_t>(VT_TICKTYPE, 0));
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_DATATYPE) &&
           VerifyField<int64_t>(verifier, VT_ENDTIME) &&
           VerifyField<uint8_t>(verifier, VT_ISFILLFORWARD) &&
           VerifyOffset(verifier, VT_SYMBOL) &&
           verifier.VerifyTable(Symbol()) &&
           VerifyField<int64_t>(verifier, VT_TIME) &&
           VerifyField<double>(verifier, VT_VALUE) &&
           VerifyField<double>(verifier, VT_ASKPRICE) &&
           VerifyField<double>(verifier, VT_ASKSIZE) &&
           VerifyField<double>(verifier, VT_BIDPRICE) &&
           VerifyField<double>(verifier, VT_BIDSIZE) &&
           VerifyOffset(verifier, VT_EXCHANGE) &&
           verifier.VerifyString(Exchange()) &&
           VerifyField<double>(verifier, VT_QUANTITY) &&
           VerifyOffset(verifier, VT_SALECONDITION) &&
           verifier.VerifyString(SaleCondition()) &&
           VerifyField<uint8_t>(verifier, VT_SUSPICIOUS) &&
           VerifyField<int32_t>(verifier, VT_TICKTYPE) &&
           verifier.EndTable();
  }
};

struct TickBuilder {
  typedef Tick Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_DataType(MarketDataType DataType) {
    fbb_.AddElement<int32_t>(Tick::VT_DATATYPE, static_cast<int32_t>(DataType), 0);
  }
  void add_EndTime(int64_t EndTime) {
    fbb_.AddElement<int64_t>(Tick::VT_ENDTIME, EndTime, 0);
  }
  void add_IsFillForward(bool IsFillForward) {
    fbb_.AddElement<uint8_t>(Tick::VT_ISFILLFORWARD, static_cast<uint8_t>(IsFillForward), 0);
  }
  void add_Symbol(flatbuffers::Offset<QCSymbol> Symbol) {
    fbb_.AddOffset(Tick::VT_SYMBOL, Symbol);
  }
  void add_Time(int64_t Time) {
    fbb_.AddElement<int64_t>(Tick::VT_TIME, Time, 0);
  }
  void add_Value(double Value) {
    fbb_.AddElement<double>(Tick::VT_VALUE, Value, 0.0);
  }
  void add_AskPrice(double AskPrice) {
    fbb_.AddElement<double>(Tick::VT_ASKPRICE, AskPrice, 0.0);
  }
  void add_AskSize(double AskSize) {
    fbb_.AddElement<double>(Tick::VT_ASKSIZE, AskSize, 0.0);
  }
  void add_BidPrice(double BidPrice) {
    fbb_.AddElement<double>(Tick::VT_BIDPRICE, BidPrice, 0.0);
  }
  void add_BidSize(double BidSize) {
    fbb_.AddElement<double>(Tick::VT_BIDSIZE, BidSize, 0.0);
  }
  void add_Exchange(flatbuffers::Offset<flatbuffers::String> Exchange) {
    fbb_.AddOffset(Tick::VT_EXCHANGE, Exchange);
  }
  void add_Quantity(double Quantity) {
    fbb_.AddElement<double>(Tick::VT_QUANTITY, Quantity, 0.0);
  }
  void add_SaleCondition(flatbuffers::Offset<flatbuffers::String> SaleCondition) {
    fbb_.AddOffset(Tick::VT_SALECONDITION, SaleCondition);
  }
  void add_Suspicious(bool Suspicious) {
    fbb_.AddElement<uint8_t>(Tick::VT_SUSPICIOUS, static_cast<uint8_t>(Suspicious), 0);
  }
  void add_TickType(TickType TickType) {
    fbb_.AddElement<int32_t>(Tick::VT_TICKTYPE, static_cast<int32_t>(TickType), 0);
  }
  explicit TickBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  TickBuilder &operator=(const TickBuilder &);
  flatbuffers::Offset<Tick> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Tick>(end);
    return o;
  }
};

inline flatbuffers::Offset<Tick> CreateTick(
    flatbuffers::FlatBufferBuilder &_fbb,
    MarketDataType DataType = MarketDataType_Base,
    int64_t EndTime = 0,
    bool IsFillForward = false,
    flatbuffers::Offset<QCSymbol> Symbol = 0,
    int64_t Time = 0,
    double Value = 0.0,
    double AskPrice = 0.0,
    double AskSize = 0.0,
    double BidPrice = 0.0,
    double BidSize = 0.0,
    flatbuffers::Offset<flatbuffers::String> Exchange = 0,
    double Quantity = 0.0,
    flatbuffers::Offset<flatbuffers::String> SaleCondition = 0,
    bool Suspicious = false,
    TickType TickType = TickType_Trade) {
  TickBuilder builder_(_fbb);
  builder_.add_Quantity(Quantity);
  builder_.add_BidSize(BidSize);
  builder_.add_BidPrice(BidPrice);
  builder_.add_AskSize(AskSize);
  builder_.add_AskPrice(AskPrice);
  builder_.add_Value(Value);
  builder_.add_Time(Time);
  builder_.add_EndTime(EndTime);
  builder_.add_TickType(TickType);
  builder_.add_SaleCondition(SaleCondition);
  builder_.add_Exchange(Exchange);
  builder_.add_Symbol(Symbol);
  builder_.add_DataType(DataType);
  builder_.add_Suspicious(Suspicious);
  builder_.add_IsFillForward(IsFillForward);
  return builder_.Finish();
}

inline flatbuffers::Offset<Tick> CreateTickDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    MarketDataType DataType = MarketDataType_Base,
    int64_t EndTime = 0,
    bool IsFillForward = false,
    flatbuffers::Offset<QCSymbol> Symbol = 0,
    int64_t Time = 0,
    double Value = 0.0,
    double AskPrice = 0.0,
    double AskSize = 0.0,
    double BidPrice = 0.0,
    double BidSize = 0.0,
    const char *Exchange = nullptr,
    double Quantity = 0.0,
    const char *SaleCondition = nullptr,
    bool Suspicious = false,
    TickType TickType = TickType_Trade) {
  auto Exchange__ = Exchange ? _fbb.CreateString(Exchange) : 0;
  auto SaleCondition__ = SaleCondition ? _fbb.CreateString(SaleCondition) : 0;
  return CreateTick(
      _fbb,
      DataType,
      EndTime,
      IsFillForward,
      Symbol,
      Time,
      Value,
      AskPrice,
      AskSize,
      BidPrice,
      BidSize,
      Exchange__,
      Quantity,
      SaleCondition__,
      Suspicious,
      TickType);
}

struct TradeBar FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef TradeBarBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_DATATYPE = 4,
    VT_ENDTIME = 6,
    VT_ISFILLFORWARD = 8,
    VT_SYMBOL = 10,
    VT_TIME = 12,
    VT_VALUE = 14,
    VT_CLOSE = 16,
    VT_HIGH = 18,
    VT_LOW = 20,
    VT_OPEN = 22,
    VT_PERIOD = 24,
    VT_VOLUME = 26
  };
  MarketDataType DataType() const {
    return static_cast<MarketDataType>(GetField<int32_t>(VT_DATATYPE, 0));
  }
  int64_t EndTime() const {
    return GetField<int64_t>(VT_ENDTIME, 0);
  }
  bool IsFillForward() const {
    return GetField<uint8_t>(VT_ISFILLFORWARD, 0) != 0;
  }
  const QCSymbol *Symbol() const {
    return GetPointer<const QCSymbol *>(VT_SYMBOL);
  }
  int64_t Time() const {
    return GetField<int64_t>(VT_TIME, 0);
  }
  double Value() const {
    return GetField<double>(VT_VALUE, 0.0);
  }
  double Close() const {
    return GetField<double>(VT_CLOSE, 0.0);
  }
  double High() const {
    return GetField<double>(VT_HIGH, 0.0);
  }
  double Low() const {
    return GetField<double>(VT_LOW, 0.0);
  }
  double Open() const {
    return GetField<double>(VT_OPEN, 0.0);
  }
  int64_t Period() const {
    return GetField<int64_t>(VT_PERIOD, 0);
  }
  double Volume() const {
    return GetField<double>(VT_VOLUME, 0.0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_DATATYPE) &&
           VerifyField<int64_t>(verifier, VT_ENDTIME) &&
           VerifyField<uint8_t>(verifier, VT_ISFILLFORWARD) &&
           VerifyOffset(verifier, VT_SYMBOL) &&
           verifier.VerifyTable(Symbol()) &&
           VerifyField<int64_t>(verifier, VT_TIME) &&
           VerifyField<double>(verifier, VT_VALUE) &&
           VerifyField<double>(verifier, VT_CLOSE) &&
           VerifyField<double>(verifier, VT_HIGH) &&
           VerifyField<double>(verifier, VT_LOW) &&
           VerifyField<double>(verifier, VT_OPEN) &&
           VerifyField<int64_t>(verifier, VT_PERIOD) &&
           VerifyField<double>(verifier, VT_VOLUME) &&
           verifier.EndTable();
  }
};

struct TradeBarBuilder {
  typedef TradeBar Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_DataType(MarketDataType DataType) {
    fbb_.AddElement<int32_t>(TradeBar::VT_DATATYPE, static_cast<int32_t>(DataType), 0);
  }
  void add_EndTime(int64_t EndTime) {
    fbb_.AddElement<int64_t>(TradeBar::VT_ENDTIME, EndTime, 0);
  }
  void add_IsFillForward(bool IsFillForward) {
    fbb_.AddElement<uint8_t>(TradeBar::VT_ISFILLFORWARD, static_cast<uint8_t>(IsFillForward), 0);
  }
  void add_Symbol(flatbuffers::Offset<QCSymbol> Symbol) {
    fbb_.AddOffset(TradeBar::VT_SYMBOL, Symbol);
  }
  void add_Time(int64_t Time) {
    fbb_.AddElement<int64_t>(TradeBar::VT_TIME, Time, 0);
  }
  void add_Value(double Value) {
    fbb_.AddElement<double>(TradeBar::VT_VALUE, Value, 0.0);
  }
  void add_Close(double Close) {
    fbb_.AddElement<double>(TradeBar::VT_CLOSE, Close, 0.0);
  }
  void add_High(double High) {
    fbb_.AddElement<double>(TradeBar::VT_HIGH, High, 0.0);
  }
  void add_Low(double Low) {
    fbb_.AddElement<double>(TradeBar::VT_LOW, Low, 0.0);
  }
  void add_Open(double Open) {
    fbb_.AddElement<double>(TradeBar::VT_OPEN, Open, 0.0);
  }
  void add_Period(int64_t Period) {
    fbb_.AddElement<int64_t>(TradeBar::VT_PERIOD, Period, 0);
  }
  void add_Volume(double Volume) {
    fbb_.AddElement<double>(TradeBar::VT_VOLUME, Volume, 0.0);
  }
  explicit TradeBarBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  TradeBarBuilder &operator=(const TradeBarBuilder &);
  flatbuffers::Offset<TradeBar> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<TradeBar>(end);
    return o;
  }
};

inline flatbuffers::Offset<TradeBar> CreateTradeBar(
    flatbuffers::FlatBufferBuilder &_fbb,
    MarketDataType DataType = MarketDataType_Base,
    int64_t EndTime = 0,
    bool IsFillForward = false,
    flatbuffers::Offset<QCSymbol> Symbol = 0,
    int64_t Time = 0,
    double Value = 0.0,
    double Close = 0.0,
    double High = 0.0,
    double Low = 0.0,
    double Open = 0.0,
    int64_t Period = 0,
    double Volume = 0.0) {
  TradeBarBuilder builder_(_fbb);
  builder_.add_Volume(Volume);
  builder_.add_Period(Period);
  builder_.add_Open(Open);
  builder_.add_Low(Low);
  builder_.add_High(High);
  builder_.add_Close(Close);
  builder_.add_Value(Value);
  builder_.add_Time(Time);
  builder_.add_EndTime(EndTime);
  builder_.add_Symbol(Symbol);
  builder_.add_DataType(DataType);
  builder_.add_IsFillForward(IsFillForward);
  return builder_.Finish();
}

inline const BaseDataCollection *GetBaseDataCollection(const void *buf) {
  return flatbuffers::GetRoot<BaseDataCollection>(buf);
}

inline const BaseDataCollection *GetSizePrefixedBaseDataCollection(const void *buf) {
  return flatbuffers::GetSizePrefixedRoot<BaseDataCollection>(buf);
}

inline bool VerifyBaseDataCollectionBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<BaseDataCollection>(nullptr);
}

inline bool VerifySizePrefixedBaseDataCollectionBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<BaseDataCollection>(nullptr);
}

inline void FinishBaseDataCollectionBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<BaseDataCollection> root) {
  fbb.Finish(root);
}

inline void FinishSizePrefixedBaseDataCollectionBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<BaseDataCollection> root) {
  fbb.FinishSizePrefixed(root);
}

#endif  // FLATBUFFERS_GENERATED_QC_H_
