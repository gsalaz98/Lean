// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: qc.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_qc_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_qc_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3011000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3011004 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "bcl.pb.h"
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_qc_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_qc_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxillaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[7]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const ::PROTOBUF_NAMESPACE_ID::uint32 offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_qc_2eproto;
class BaseData;
class BaseDataDefaultTypeInternal;
extern BaseDataDefaultTypeInternal _BaseData_default_instance_;
class List_BaseData;
class List_BaseDataDefaultTypeInternal;
extern List_BaseDataDefaultTypeInternal _List_BaseData_default_instance_;
class SecurityIdentifier;
class SecurityIdentifierDefaultTypeInternal;
extern SecurityIdentifierDefaultTypeInternal _SecurityIdentifier_default_instance_;
class SidBox;
class SidBoxDefaultTypeInternal;
extern SidBoxDefaultTypeInternal _SidBox_default_instance_;
class Symbol;
class SymbolDefaultTypeInternal;
extern SymbolDefaultTypeInternal _Symbol_default_instance_;
class Tick;
class TickDefaultTypeInternal;
extern TickDefaultTypeInternal _Tick_default_instance_;
class TradeBar;
class TradeBarDefaultTypeInternal;
extern TradeBarDefaultTypeInternal _TradeBar_default_instance_;
PROTOBUF_NAMESPACE_OPEN
template<> ::BaseData* Arena::CreateMaybeMessage<::BaseData>(Arena*);
template<> ::List_BaseData* Arena::CreateMaybeMessage<::List_BaseData>(Arena*);
template<> ::SecurityIdentifier* Arena::CreateMaybeMessage<::SecurityIdentifier>(Arena*);
template<> ::SidBox* Arena::CreateMaybeMessage<::SidBox>(Arena*);
template<> ::Symbol* Arena::CreateMaybeMessage<::Symbol>(Arena*);
template<> ::Tick* Arena::CreateMaybeMessage<::Tick>(Arena*);
template<> ::TradeBar* Arena::CreateMaybeMessage<::TradeBar>(Arena*);
PROTOBUF_NAMESPACE_CLOSE

enum MarketDataType : int {
  BaseType = 0,
  TradeBarType = 1,
  TickTypeType = 2,
  AuxiliaryType = 3,
  QuoteBarType = 4,
  OptionChainType = 5,
  FuturesChainType = 6,
  MarketDataType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  MarketDataType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool MarketDataType_IsValid(int value);
constexpr MarketDataType MarketDataType_MIN = BaseType;
constexpr MarketDataType MarketDataType_MAX = FuturesChainType;
constexpr int MarketDataType_ARRAYSIZE = MarketDataType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* MarketDataType_descriptor();
template<typename T>
inline const std::string& MarketDataType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, MarketDataType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function MarketDataType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    MarketDataType_descriptor(), enum_t_value);
}
inline bool MarketDataType_Parse(
    const std::string& name, MarketDataType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<MarketDataType>(
    MarketDataType_descriptor(), name, value);
}
enum OptionRight : int {
  Call = 0,
  Put = 1,
  OptionRight_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  OptionRight_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool OptionRight_IsValid(int value);
constexpr OptionRight OptionRight_MIN = Call;
constexpr OptionRight OptionRight_MAX = Put;
constexpr int OptionRight_ARRAYSIZE = OptionRight_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* OptionRight_descriptor();
template<typename T>
inline const std::string& OptionRight_Name(T enum_t_value) {
  static_assert(::std::is_same<T, OptionRight>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function OptionRight_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    OptionRight_descriptor(), enum_t_value);
}
inline bool OptionRight_Parse(
    const std::string& name, OptionRight* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<OptionRight>(
    OptionRight_descriptor(), name, value);
}
enum OptionStyle : int {
  American = 0,
  European = 1,
  OptionStyle_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  OptionStyle_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool OptionStyle_IsValid(int value);
constexpr OptionStyle OptionStyle_MIN = American;
constexpr OptionStyle OptionStyle_MAX = European;
constexpr int OptionStyle_ARRAYSIZE = OptionStyle_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* OptionStyle_descriptor();
template<typename T>
inline const std::string& OptionStyle_Name(T enum_t_value) {
  static_assert(::std::is_same<T, OptionStyle>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function OptionStyle_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    OptionStyle_descriptor(), enum_t_value);
}
inline bool OptionStyle_Parse(
    const std::string& name, OptionStyle* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<OptionStyle>(
    OptionStyle_descriptor(), name, value);
}
enum SecurityType : int {
  Base = 0,
  Equity = 1,
  Option = 2,
  Commodity = 3,
  Forex = 4,
  Future = 5,
  Cfd = 6,
  Crypto = 7,
  SecurityType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  SecurityType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool SecurityType_IsValid(int value);
constexpr SecurityType SecurityType_MIN = Base;
constexpr SecurityType SecurityType_MAX = Crypto;
constexpr int SecurityType_ARRAYSIZE = SecurityType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* SecurityType_descriptor();
template<typename T>
inline const std::string& SecurityType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, SecurityType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function SecurityType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    SecurityType_descriptor(), enum_t_value);
}
inline bool SecurityType_Parse(
    const std::string& name, SecurityType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<SecurityType>(
    SecurityType_descriptor(), name, value);
}
enum TickType : int {
  Trade = 0,
  Quote = 1,
  OpenInterest = 2,
  TickType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  TickType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool TickType_IsValid(int value);
constexpr TickType TickType_MIN = Trade;
constexpr TickType TickType_MAX = OpenInterest;
constexpr int TickType_ARRAYSIZE = TickType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* TickType_descriptor();
template<typename T>
inline const std::string& TickType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, TickType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function TickType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    TickType_descriptor(), enum_t_value);
}
inline bool TickType_Parse(
    const std::string& name, TickType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<TickType>(
    TickType_descriptor(), name, value);
}
// ===================================================================

class BaseData :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:BaseData) */ {
 public:
  BaseData();
  virtual ~BaseData();

  BaseData(const BaseData& from);
  BaseData(BaseData&& from) noexcept
    : BaseData() {
    *this = ::std::move(from);
  }

  inline BaseData& operator=(const BaseData& from) {
    CopyFrom(from);
    return *this;
  }
  inline BaseData& operator=(BaseData&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const BaseData& default_instance();

  enum SubtypeCase {
    kTradeBar = 200,
    kTick = 202,
    SUBTYPE_NOT_SET = 0,
  };

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const BaseData* internal_default_instance() {
    return reinterpret_cast<const BaseData*>(
               &_BaseData_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(BaseData& a, BaseData& b) {
    a.Swap(&b);
  }
  inline void Swap(BaseData* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline BaseData* New() const final {
    return CreateMaybeMessage<BaseData>(nullptr);
  }

  BaseData* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<BaseData>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const BaseData& from);
  void MergeFrom(const BaseData& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BaseData* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "BaseData";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_qc_2eproto);
    return ::descriptor_table_qc_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEndTimeFieldNumber = 2,
    kSymbolFieldNumber = 4,
    kTimeFieldNumber = 5,
    kValueFieldNumber = 6,
    kDataTypeFieldNumber = 1,
    kIsFillForwardFieldNumber = 3,
    kTradeBarFieldNumber = 200,
    kTickFieldNumber = 202,
  };
  // .bcl.DateTime EndTime = 2;
  bool has_endtime() const;
  private:
  bool _internal_has_endtime() const;
  public:
  void clear_endtime();
  const ::bcl::DateTime& endtime() const;
  ::bcl::DateTime* release_endtime();
  ::bcl::DateTime* mutable_endtime();
  void set_allocated_endtime(::bcl::DateTime* endtime);
  private:
  const ::bcl::DateTime& _internal_endtime() const;
  ::bcl::DateTime* _internal_mutable_endtime();
  public:

  // .Symbol Symbol = 4;
  bool has_symbol() const;
  private:
  bool _internal_has_symbol() const;
  public:
  void clear_symbol();
  const ::Symbol& symbol() const;
  ::Symbol* release_symbol();
  ::Symbol* mutable_symbol();
  void set_allocated_symbol(::Symbol* symbol);
  private:
  const ::Symbol& _internal_symbol() const;
  ::Symbol* _internal_mutable_symbol();
  public:

  // .bcl.DateTime Time = 5;
  bool has_time() const;
  private:
  bool _internal_has_time() const;
  public:
  void clear_time();
  const ::bcl::DateTime& time() const;
  ::bcl::DateTime* release_time();
  ::bcl::DateTime* mutable_time();
  void set_allocated_time(::bcl::DateTime* time);
  private:
  const ::bcl::DateTime& _internal_time() const;
  ::bcl::DateTime* _internal_mutable_time();
  public:

  // .bcl.Decimal Value = 6;
  bool has_value() const;
  private:
  bool _internal_has_value() const;
  public:
  void clear_value();
  const ::bcl::Decimal& value() const;
  ::bcl::Decimal* release_value();
  ::bcl::Decimal* mutable_value();
  void set_allocated_value(::bcl::Decimal* value);
  private:
  const ::bcl::Decimal& _internal_value() const;
  ::bcl::Decimal* _internal_mutable_value();
  public:

  // .MarketDataType DataType = 1;
  void clear_datatype();
  ::MarketDataType datatype() const;
  void set_datatype(::MarketDataType value);
  private:
  ::MarketDataType _internal_datatype() const;
  void _internal_set_datatype(::MarketDataType value);
  public:

  // bool IsFillForward = 3;
  void clear_isfillforward();
  bool isfillforward() const;
  void set_isfillforward(bool value);
  private:
  bool _internal_isfillforward() const;
  void _internal_set_isfillforward(bool value);
  public:

  // .TradeBar TradeBar = 200;
  bool has_tradebar() const;
  private:
  bool _internal_has_tradebar() const;
  public:
  void clear_tradebar();
  const ::TradeBar& tradebar() const;
  ::TradeBar* release_tradebar();
  ::TradeBar* mutable_tradebar();
  void set_allocated_tradebar(::TradeBar* tradebar);
  private:
  const ::TradeBar& _internal_tradebar() const;
  ::TradeBar* _internal_mutable_tradebar();
  public:

  // .Tick Tick = 202;
  bool has_tick() const;
  private:
  bool _internal_has_tick() const;
  public:
  void clear_tick();
  const ::Tick& tick() const;
  ::Tick* release_tick();
  ::Tick* mutable_tick();
  void set_allocated_tick(::Tick* tick);
  private:
  const ::Tick& _internal_tick() const;
  ::Tick* _internal_mutable_tick();
  public:

  void clear_subtype();
  SubtypeCase subtype_case() const;
  // @@protoc_insertion_point(class_scope:BaseData)
 private:
  class _Internal;
  void set_has_tradebar();
  void set_has_tick();

  inline bool has_subtype() const;
  inline void clear_has_subtype();

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::bcl::DateTime* endtime_;
  ::Symbol* symbol_;
  ::bcl::DateTime* time_;
  ::bcl::Decimal* value_;
  int datatype_;
  bool isfillforward_;
  union SubtypeUnion {
    SubtypeUnion() {}
    ::TradeBar* tradebar_;
    ::Tick* tick_;
  } subtype_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::uint32 _oneof_case_[1];

  friend struct ::TableStruct_qc_2eproto;
};
// -------------------------------------------------------------------

class List_BaseData :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:List_BaseData) */ {
 public:
  List_BaseData();
  virtual ~List_BaseData();

  List_BaseData(const List_BaseData& from);
  List_BaseData(List_BaseData&& from) noexcept
    : List_BaseData() {
    *this = ::std::move(from);
  }

  inline List_BaseData& operator=(const List_BaseData& from) {
    CopyFrom(from);
    return *this;
  }
  inline List_BaseData& operator=(List_BaseData&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const List_BaseData& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const List_BaseData* internal_default_instance() {
    return reinterpret_cast<const List_BaseData*>(
               &_List_BaseData_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(List_BaseData& a, List_BaseData& b) {
    a.Swap(&b);
  }
  inline void Swap(List_BaseData* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline List_BaseData* New() const final {
    return CreateMaybeMessage<List_BaseData>(nullptr);
  }

  List_BaseData* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<List_BaseData>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const List_BaseData& from);
  void MergeFrom(const List_BaseData& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(List_BaseData* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "List_BaseData";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_qc_2eproto);
    return ::descriptor_table_qc_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kItemsFieldNumber = 1,
  };
  // repeated .BaseData items = 1;
  int items_size() const;
  private:
  int _internal_items_size() const;
  public:
  void clear_items();
  ::BaseData* mutable_items(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::BaseData >*
      mutable_items();
  private:
  const ::BaseData& _internal_items(int index) const;
  ::BaseData* _internal_add_items();
  public:
  const ::BaseData& items(int index) const;
  ::BaseData* add_items();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::BaseData >&
      items() const;

  // @@protoc_insertion_point(class_scope:List_BaseData)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::BaseData > items_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_qc_2eproto;
};
// -------------------------------------------------------------------

class SecurityIdentifier :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:SecurityIdentifier) */ {
 public:
  SecurityIdentifier();
  virtual ~SecurityIdentifier();

  SecurityIdentifier(const SecurityIdentifier& from);
  SecurityIdentifier(SecurityIdentifier&& from) noexcept
    : SecurityIdentifier() {
    *this = ::std::move(from);
  }

  inline SecurityIdentifier& operator=(const SecurityIdentifier& from) {
    CopyFrom(from);
    return *this;
  }
  inline SecurityIdentifier& operator=(SecurityIdentifier&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const SecurityIdentifier& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SecurityIdentifier* internal_default_instance() {
    return reinterpret_cast<const SecurityIdentifier*>(
               &_SecurityIdentifier_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(SecurityIdentifier& a, SecurityIdentifier& b) {
    a.Swap(&b);
  }
  inline void Swap(SecurityIdentifier* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline SecurityIdentifier* New() const final {
    return CreateMaybeMessage<SecurityIdentifier>(nullptr);
  }

  SecurityIdentifier* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<SecurityIdentifier>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const SecurityIdentifier& from);
  void MergeFrom(const SecurityIdentifier& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SecurityIdentifier* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "SecurityIdentifier";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_qc_2eproto);
    return ::descriptor_table_qc_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSymbolFieldNumber = 1,
    kUnderlyingFieldNumber = 3,
    kStrikePriceFieldNumber = 5,
    kDateFieldNumber = 8,
    kPropertiesFieldNumber = 2,
    kHashCodeFieldNumber = 4,
    kOptionStyleFieldNumber = 6,
    kOptionRightFieldNumber = 7,
    kSecurityTypeFieldNumber = 9,
  };
  // string _symbol = 1;
  void clear__symbol();
  const std::string& _symbol() const;
  void set__symbol(const std::string& value);
  void set__symbol(std::string&& value);
  void set__symbol(const char* value);
  void set__symbol(const char* value, size_t size);
  std::string* mutable__symbol();
  std::string* release__symbol();
  void set_allocated__symbol(std::string* _symbol);
  private:
  const std::string& _internal__symbol() const;
  void _internal_set__symbol(const std::string& value);
  std::string* _internal_mutable__symbol();
  public:

  // .SidBox _underlying = 3;
  bool has__underlying() const;
  private:
  bool _internal_has__underlying() const;
  public:
  void clear__underlying();
  const ::SidBox& _underlying() const;
  ::SidBox* release__underlying();
  ::SidBox* mutable__underlying();
  void set_allocated__underlying(::SidBox* _underlying);
  private:
  const ::SidBox& _internal__underlying() const;
  ::SidBox* _internal_mutable__underlying();
  public:

  // .bcl.Decimal _strikePrice = 5;
  bool has__strikeprice() const;
  private:
  bool _internal_has__strikeprice() const;
  public:
  void clear__strikeprice();
  const ::bcl::Decimal& _strikeprice() const;
  ::bcl::Decimal* release__strikeprice();
  ::bcl::Decimal* mutable__strikeprice();
  void set_allocated__strikeprice(::bcl::Decimal* _strikeprice);
  private:
  const ::bcl::Decimal& _internal__strikeprice() const;
  ::bcl::Decimal* _internal_mutable__strikeprice();
  public:

  // .bcl.DateTime _date = 8;
  bool has__date() const;
  private:
  bool _internal_has__date() const;
  public:
  void clear__date();
  const ::bcl::DateTime& _date() const;
  ::bcl::DateTime* release__date();
  ::bcl::DateTime* mutable__date();
  void set_allocated__date(::bcl::DateTime* _date);
  private:
  const ::bcl::DateTime& _internal__date() const;
  ::bcl::DateTime* _internal_mutable__date();
  public:

  // uint64 _properties = 2;
  void clear__properties();
  ::PROTOBUF_NAMESPACE_ID::uint64 _properties() const;
  void set__properties(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal__properties() const;
  void _internal_set__properties(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // int32 _hashCode = 4;
  void clear__hashcode();
  ::PROTOBUF_NAMESPACE_ID::int32 _hashcode() const;
  void set__hashcode(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal__hashcode() const;
  void _internal_set__hashcode(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // .OptionStyle _optionStyle = 6;
  void clear__optionstyle();
  ::OptionStyle _optionstyle() const;
  void set__optionstyle(::OptionStyle value);
  private:
  ::OptionStyle _internal__optionstyle() const;
  void _internal_set__optionstyle(::OptionStyle value);
  public:

  // .OptionRight _optionRight = 7;
  void clear__optionright();
  ::OptionRight _optionright() const;
  void set__optionright(::OptionRight value);
  private:
  ::OptionRight _internal__optionright() const;
  void _internal_set__optionright(::OptionRight value);
  public:

  // .SecurityType SecurityType = 9;
  void clear_securitytype();
  ::SecurityType securitytype() const;
  void set_securitytype(::SecurityType value);
  private:
  ::SecurityType _internal_securitytype() const;
  void _internal_set_securitytype(::SecurityType value);
  public:

  // @@protoc_insertion_point(class_scope:SecurityIdentifier)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr _symbol_;
  ::SidBox* _underlying_;
  ::bcl::Decimal* _strikeprice_;
  ::bcl::DateTime* _date_;
  ::PROTOBUF_NAMESPACE_ID::uint64 _properties_;
  ::PROTOBUF_NAMESPACE_ID::int32 _hashcode_;
  int _optionstyle_;
  int _optionright_;
  int securitytype_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_qc_2eproto;
};
// -------------------------------------------------------------------

class SidBox :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:SidBox) */ {
 public:
  SidBox();
  virtual ~SidBox();

  SidBox(const SidBox& from);
  SidBox(SidBox&& from) noexcept
    : SidBox() {
    *this = ::std::move(from);
  }

  inline SidBox& operator=(const SidBox& from) {
    CopyFrom(from);
    return *this;
  }
  inline SidBox& operator=(SidBox&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const SidBox& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SidBox* internal_default_instance() {
    return reinterpret_cast<const SidBox*>(
               &_SidBox_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(SidBox& a, SidBox& b) {
    a.Swap(&b);
  }
  inline void Swap(SidBox* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline SidBox* New() const final {
    return CreateMaybeMessage<SidBox>(nullptr);
  }

  SidBox* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<SidBox>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const SidBox& from);
  void MergeFrom(const SidBox& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SidBox* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "SidBox";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_qc_2eproto);
    return ::descriptor_table_qc_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSecurityIdentifierFieldNumber = 1,
  };
  // .SecurityIdentifier SecurityIdentifier = 1;
  bool has_securityidentifier() const;
  private:
  bool _internal_has_securityidentifier() const;
  public:
  void clear_securityidentifier();
  const ::SecurityIdentifier& securityidentifier() const;
  ::SecurityIdentifier* release_securityidentifier();
  ::SecurityIdentifier* mutable_securityidentifier();
  void set_allocated_securityidentifier(::SecurityIdentifier* securityidentifier);
  private:
  const ::SecurityIdentifier& _internal_securityidentifier() const;
  ::SecurityIdentifier* _internal_mutable_securityidentifier();
  public:

  // @@protoc_insertion_point(class_scope:SidBox)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::SecurityIdentifier* securityidentifier_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_qc_2eproto;
};
// -------------------------------------------------------------------

class Symbol :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Symbol) */ {
 public:
  Symbol();
  virtual ~Symbol();

  Symbol(const Symbol& from);
  Symbol(Symbol&& from) noexcept
    : Symbol() {
    *this = ::std::move(from);
  }

  inline Symbol& operator=(const Symbol& from) {
    CopyFrom(from);
    return *this;
  }
  inline Symbol& operator=(Symbol&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Symbol& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Symbol* internal_default_instance() {
    return reinterpret_cast<const Symbol*>(
               &_Symbol_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(Symbol& a, Symbol& b) {
    a.Swap(&b);
  }
  inline void Swap(Symbol* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Symbol* New() const final {
    return CreateMaybeMessage<Symbol>(nullptr);
  }

  Symbol* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Symbol>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Symbol& from);
  void MergeFrom(const Symbol& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Symbol* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Symbol";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_qc_2eproto);
    return ::descriptor_table_qc_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kValueFieldNumber = 5,
    kIDFieldNumber = 2,
    kUnderlyingFieldNumber = 4,
    kHasUnderlyingFieldNumber = 1,
    kSecurityTypeFieldNumber = 3,
  };
  // string Value = 5;
  void clear_value();
  const std::string& value() const;
  void set_value(const std::string& value);
  void set_value(std::string&& value);
  void set_value(const char* value);
  void set_value(const char* value, size_t size);
  std::string* mutable_value();
  std::string* release_value();
  void set_allocated_value(std::string* value);
  private:
  const std::string& _internal_value() const;
  void _internal_set_value(const std::string& value);
  std::string* _internal_mutable_value();
  public:

  // .SecurityIdentifier ID = 2;
  bool has_id() const;
  private:
  bool _internal_has_id() const;
  public:
  void clear_id();
  const ::SecurityIdentifier& id() const;
  ::SecurityIdentifier* release_id();
  ::SecurityIdentifier* mutable_id();
  void set_allocated_id(::SecurityIdentifier* id);
  private:
  const ::SecurityIdentifier& _internal_id() const;
  ::SecurityIdentifier* _internal_mutable_id();
  public:

  // .Symbol Underlying = 4;
  bool has_underlying() const;
  private:
  bool _internal_has_underlying() const;
  public:
  void clear_underlying();
  const ::Symbol& underlying() const;
  ::Symbol* release_underlying();
  ::Symbol* mutable_underlying();
  void set_allocated_underlying(::Symbol* underlying);
  private:
  const ::Symbol& _internal_underlying() const;
  ::Symbol* _internal_mutable_underlying();
  public:

  // bool HasUnderlying = 1;
  void clear_hasunderlying();
  bool hasunderlying() const;
  void set_hasunderlying(bool value);
  private:
  bool _internal_hasunderlying() const;
  void _internal_set_hasunderlying(bool value);
  public:

  // .SecurityType SecurityType = 3;
  void clear_securitytype();
  ::SecurityType securitytype() const;
  void set_securitytype(::SecurityType value);
  private:
  ::SecurityType _internal_securitytype() const;
  void _internal_set_securitytype(::SecurityType value);
  public:

  // @@protoc_insertion_point(class_scope:Symbol)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr value_;
  ::SecurityIdentifier* id_;
  ::Symbol* underlying_;
  bool hasunderlying_;
  int securitytype_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_qc_2eproto;
};
// -------------------------------------------------------------------

class Tick :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Tick) */ {
 public:
  Tick();
  virtual ~Tick();

  Tick(const Tick& from);
  Tick(Tick&& from) noexcept
    : Tick() {
    *this = ::std::move(from);
  }

  inline Tick& operator=(const Tick& from) {
    CopyFrom(from);
    return *this;
  }
  inline Tick& operator=(Tick&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Tick& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Tick* internal_default_instance() {
    return reinterpret_cast<const Tick*>(
               &_Tick_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(Tick& a, Tick& b) {
    a.Swap(&b);
  }
  inline void Swap(Tick* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Tick* New() const final {
    return CreateMaybeMessage<Tick>(nullptr);
  }

  Tick* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Tick>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Tick& from);
  void MergeFrom(const Tick& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Tick* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Tick";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_qc_2eproto);
    return ::descriptor_table_qc_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kExchangeFieldNumber = 5,
    kSaleConditionFieldNumber = 7,
    kAskPriceFieldNumber = 1,
    kAskSizeFieldNumber = 2,
    kBidPriceFieldNumber = 3,
    kBidSizeFieldNumber = 4,
    kQuantityFieldNumber = 6,
    kSuspiciousFieldNumber = 8,
    kTickTypeFieldNumber = 9,
  };
  // string Exchange = 5;
  void clear_exchange();
  const std::string& exchange() const;
  void set_exchange(const std::string& value);
  void set_exchange(std::string&& value);
  void set_exchange(const char* value);
  void set_exchange(const char* value, size_t size);
  std::string* mutable_exchange();
  std::string* release_exchange();
  void set_allocated_exchange(std::string* exchange);
  private:
  const std::string& _internal_exchange() const;
  void _internal_set_exchange(const std::string& value);
  std::string* _internal_mutable_exchange();
  public:

  // string SaleCondition = 7;
  void clear_salecondition();
  const std::string& salecondition() const;
  void set_salecondition(const std::string& value);
  void set_salecondition(std::string&& value);
  void set_salecondition(const char* value);
  void set_salecondition(const char* value, size_t size);
  std::string* mutable_salecondition();
  std::string* release_salecondition();
  void set_allocated_salecondition(std::string* salecondition);
  private:
  const std::string& _internal_salecondition() const;
  void _internal_set_salecondition(const std::string& value);
  std::string* _internal_mutable_salecondition();
  public:

  // .bcl.Decimal AskPrice = 1;
  bool has_askprice() const;
  private:
  bool _internal_has_askprice() const;
  public:
  void clear_askprice();
  const ::bcl::Decimal& askprice() const;
  ::bcl::Decimal* release_askprice();
  ::bcl::Decimal* mutable_askprice();
  void set_allocated_askprice(::bcl::Decimal* askprice);
  private:
  const ::bcl::Decimal& _internal_askprice() const;
  ::bcl::Decimal* _internal_mutable_askprice();
  public:

  // .bcl.Decimal AskSize = 2;
  bool has_asksize() const;
  private:
  bool _internal_has_asksize() const;
  public:
  void clear_asksize();
  const ::bcl::Decimal& asksize() const;
  ::bcl::Decimal* release_asksize();
  ::bcl::Decimal* mutable_asksize();
  void set_allocated_asksize(::bcl::Decimal* asksize);
  private:
  const ::bcl::Decimal& _internal_asksize() const;
  ::bcl::Decimal* _internal_mutable_asksize();
  public:

  // .bcl.Decimal BidPrice = 3;
  bool has_bidprice() const;
  private:
  bool _internal_has_bidprice() const;
  public:
  void clear_bidprice();
  const ::bcl::Decimal& bidprice() const;
  ::bcl::Decimal* release_bidprice();
  ::bcl::Decimal* mutable_bidprice();
  void set_allocated_bidprice(::bcl::Decimal* bidprice);
  private:
  const ::bcl::Decimal& _internal_bidprice() const;
  ::bcl::Decimal* _internal_mutable_bidprice();
  public:

  // .bcl.Decimal BidSize = 4;
  bool has_bidsize() const;
  private:
  bool _internal_has_bidsize() const;
  public:
  void clear_bidsize();
  const ::bcl::Decimal& bidsize() const;
  ::bcl::Decimal* release_bidsize();
  ::bcl::Decimal* mutable_bidsize();
  void set_allocated_bidsize(::bcl::Decimal* bidsize);
  private:
  const ::bcl::Decimal& _internal_bidsize() const;
  ::bcl::Decimal* _internal_mutable_bidsize();
  public:

  // .bcl.Decimal Quantity = 6;
  bool has_quantity() const;
  private:
  bool _internal_has_quantity() const;
  public:
  void clear_quantity();
  const ::bcl::Decimal& quantity() const;
  ::bcl::Decimal* release_quantity();
  ::bcl::Decimal* mutable_quantity();
  void set_allocated_quantity(::bcl::Decimal* quantity);
  private:
  const ::bcl::Decimal& _internal_quantity() const;
  ::bcl::Decimal* _internal_mutable_quantity();
  public:

  // bool Suspicious = 8;
  void clear_suspicious();
  bool suspicious() const;
  void set_suspicious(bool value);
  private:
  bool _internal_suspicious() const;
  void _internal_set_suspicious(bool value);
  public:

  // .TickType TickType = 9;
  void clear_ticktype();
  ::TickType ticktype() const;
  void set_ticktype(::TickType value);
  private:
  ::TickType _internal_ticktype() const;
  void _internal_set_ticktype(::TickType value);
  public:

  // @@protoc_insertion_point(class_scope:Tick)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr exchange_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr salecondition_;
  ::bcl::Decimal* askprice_;
  ::bcl::Decimal* asksize_;
  ::bcl::Decimal* bidprice_;
  ::bcl::Decimal* bidsize_;
  ::bcl::Decimal* quantity_;
  bool suspicious_;
  int ticktype_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_qc_2eproto;
};
// -------------------------------------------------------------------

class TradeBar :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:TradeBar) */ {
 public:
  TradeBar();
  virtual ~TradeBar();

  TradeBar(const TradeBar& from);
  TradeBar(TradeBar&& from) noexcept
    : TradeBar() {
    *this = ::std::move(from);
  }

  inline TradeBar& operator=(const TradeBar& from) {
    CopyFrom(from);
    return *this;
  }
  inline TradeBar& operator=(TradeBar&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const TradeBar& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const TradeBar* internal_default_instance() {
    return reinterpret_cast<const TradeBar*>(
               &_TradeBar_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(TradeBar& a, TradeBar& b) {
    a.Swap(&b);
  }
  inline void Swap(TradeBar* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline TradeBar* New() const final {
    return CreateMaybeMessage<TradeBar>(nullptr);
  }

  TradeBar* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<TradeBar>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const TradeBar& from);
  void MergeFrom(const TradeBar& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TradeBar* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "TradeBar";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_qc_2eproto);
    return ::descriptor_table_qc_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCloseFieldNumber = 1,
    kEndTimeFieldNumber = 2,
    kHighFieldNumber = 3,
    kLowFieldNumber = 4,
    kOpenFieldNumber = 5,
    kPeriodFieldNumber = 6,
    kVolumeFieldNumber = 7,
  };
  // .bcl.Decimal Close = 1;
  bool has_close() const;
  private:
  bool _internal_has_close() const;
  public:
  void clear_close();
  const ::bcl::Decimal& close() const;
  ::bcl::Decimal* release_close();
  ::bcl::Decimal* mutable_close();
  void set_allocated_close(::bcl::Decimal* close);
  private:
  const ::bcl::Decimal& _internal_close() const;
  ::bcl::Decimal* _internal_mutable_close();
  public:

  // .bcl.DateTime EndTime = 2;
  bool has_endtime() const;
  private:
  bool _internal_has_endtime() const;
  public:
  void clear_endtime();
  const ::bcl::DateTime& endtime() const;
  ::bcl::DateTime* release_endtime();
  ::bcl::DateTime* mutable_endtime();
  void set_allocated_endtime(::bcl::DateTime* endtime);
  private:
  const ::bcl::DateTime& _internal_endtime() const;
  ::bcl::DateTime* _internal_mutable_endtime();
  public:

  // .bcl.Decimal High = 3;
  bool has_high() const;
  private:
  bool _internal_has_high() const;
  public:
  void clear_high();
  const ::bcl::Decimal& high() const;
  ::bcl::Decimal* release_high();
  ::bcl::Decimal* mutable_high();
  void set_allocated_high(::bcl::Decimal* high);
  private:
  const ::bcl::Decimal& _internal_high() const;
  ::bcl::Decimal* _internal_mutable_high();
  public:

  // .bcl.Decimal Low = 4;
  bool has_low() const;
  private:
  bool _internal_has_low() const;
  public:
  void clear_low();
  const ::bcl::Decimal& low() const;
  ::bcl::Decimal* release_low();
  ::bcl::Decimal* mutable_low();
  void set_allocated_low(::bcl::Decimal* low);
  private:
  const ::bcl::Decimal& _internal_low() const;
  ::bcl::Decimal* _internal_mutable_low();
  public:

  // .bcl.Decimal Open = 5;
  bool has_open() const;
  private:
  bool _internal_has_open() const;
  public:
  void clear_open();
  const ::bcl::Decimal& open() const;
  ::bcl::Decimal* release_open();
  ::bcl::Decimal* mutable_open();
  void set_allocated_open(::bcl::Decimal* open);
  private:
  const ::bcl::Decimal& _internal_open() const;
  ::bcl::Decimal* _internal_mutable_open();
  public:

  // .bcl.TimeSpan Period = 6;
  bool has_period() const;
  private:
  bool _internal_has_period() const;
  public:
  void clear_period();
  const ::bcl::TimeSpan& period() const;
  ::bcl::TimeSpan* release_period();
  ::bcl::TimeSpan* mutable_period();
  void set_allocated_period(::bcl::TimeSpan* period);
  private:
  const ::bcl::TimeSpan& _internal_period() const;
  ::bcl::TimeSpan* _internal_mutable_period();
  public:

  // .bcl.Decimal Volume = 7;
  bool has_volume() const;
  private:
  bool _internal_has_volume() const;
  public:
  void clear_volume();
  const ::bcl::Decimal& volume() const;
  ::bcl::Decimal* release_volume();
  ::bcl::Decimal* mutable_volume();
  void set_allocated_volume(::bcl::Decimal* volume);
  private:
  const ::bcl::Decimal& _internal_volume() const;
  ::bcl::Decimal* _internal_mutable_volume();
  public:

  // @@protoc_insertion_point(class_scope:TradeBar)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::bcl::Decimal* close_;
  ::bcl::DateTime* endtime_;
  ::bcl::Decimal* high_;
  ::bcl::Decimal* low_;
  ::bcl::Decimal* open_;
  ::bcl::TimeSpan* period_;
  ::bcl::Decimal* volume_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_qc_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// BaseData

// .MarketDataType DataType = 1;
inline void BaseData::clear_datatype() {
  datatype_ = 0;
}
inline ::MarketDataType BaseData::_internal_datatype() const {
  return static_cast< ::MarketDataType >(datatype_);
}
inline ::MarketDataType BaseData::datatype() const {
  // @@protoc_insertion_point(field_get:BaseData.DataType)
  return _internal_datatype();
}
inline void BaseData::_internal_set_datatype(::MarketDataType value) {
  
  datatype_ = value;
}
inline void BaseData::set_datatype(::MarketDataType value) {
  _internal_set_datatype(value);
  // @@protoc_insertion_point(field_set:BaseData.DataType)
}

// .bcl.DateTime EndTime = 2;
inline bool BaseData::_internal_has_endtime() const {
  return this != internal_default_instance() && endtime_ != nullptr;
}
inline bool BaseData::has_endtime() const {
  return _internal_has_endtime();
}
inline const ::bcl::DateTime& BaseData::_internal_endtime() const {
  const ::bcl::DateTime* p = endtime_;
  return p != nullptr ? *p : *reinterpret_cast<const ::bcl::DateTime*>(
      &::bcl::_DateTime_default_instance_);
}
inline const ::bcl::DateTime& BaseData::endtime() const {
  // @@protoc_insertion_point(field_get:BaseData.EndTime)
  return _internal_endtime();
}
inline ::bcl::DateTime* BaseData::release_endtime() {
  // @@protoc_insertion_point(field_release:BaseData.EndTime)
  
  ::bcl::DateTime* temp = endtime_;
  endtime_ = nullptr;
  return temp;
}
inline ::bcl::DateTime* BaseData::_internal_mutable_endtime() {
  
  if (endtime_ == nullptr) {
    auto* p = CreateMaybeMessage<::bcl::DateTime>(GetArenaNoVirtual());
    endtime_ = p;
  }
  return endtime_;
}
inline ::bcl::DateTime* BaseData::mutable_endtime() {
  // @@protoc_insertion_point(field_mutable:BaseData.EndTime)
  return _internal_mutable_endtime();
}
inline void BaseData::set_allocated_endtime(::bcl::DateTime* endtime) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(endtime_);
  }
  if (endtime) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      endtime = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, endtime, submessage_arena);
    }
    
  } else {
    
  }
  endtime_ = endtime;
  // @@protoc_insertion_point(field_set_allocated:BaseData.EndTime)
}

// bool IsFillForward = 3;
inline void BaseData::clear_isfillforward() {
  isfillforward_ = false;
}
inline bool BaseData::_internal_isfillforward() const {
  return isfillforward_;
}
inline bool BaseData::isfillforward() const {
  // @@protoc_insertion_point(field_get:BaseData.IsFillForward)
  return _internal_isfillforward();
}
inline void BaseData::_internal_set_isfillforward(bool value) {
  
  isfillforward_ = value;
}
inline void BaseData::set_isfillforward(bool value) {
  _internal_set_isfillforward(value);
  // @@protoc_insertion_point(field_set:BaseData.IsFillForward)
}

// .Symbol Symbol = 4;
inline bool BaseData::_internal_has_symbol() const {
  return this != internal_default_instance() && symbol_ != nullptr;
}
inline bool BaseData::has_symbol() const {
  return _internal_has_symbol();
}
inline void BaseData::clear_symbol() {
  if (GetArenaNoVirtual() == nullptr && symbol_ != nullptr) {
    delete symbol_;
  }
  symbol_ = nullptr;
}
inline const ::Symbol& BaseData::_internal_symbol() const {
  const ::Symbol* p = symbol_;
  return p != nullptr ? *p : *reinterpret_cast<const ::Symbol*>(
      &::_Symbol_default_instance_);
}
inline const ::Symbol& BaseData::symbol() const {
  // @@protoc_insertion_point(field_get:BaseData.Symbol)
  return _internal_symbol();
}
inline ::Symbol* BaseData::release_symbol() {
  // @@protoc_insertion_point(field_release:BaseData.Symbol)
  
  ::Symbol* temp = symbol_;
  symbol_ = nullptr;
  return temp;
}
inline ::Symbol* BaseData::_internal_mutable_symbol() {
  
  if (symbol_ == nullptr) {
    auto* p = CreateMaybeMessage<::Symbol>(GetArenaNoVirtual());
    symbol_ = p;
  }
  return symbol_;
}
inline ::Symbol* BaseData::mutable_symbol() {
  // @@protoc_insertion_point(field_mutable:BaseData.Symbol)
  return _internal_mutable_symbol();
}
inline void BaseData::set_allocated_symbol(::Symbol* symbol) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete symbol_;
  }
  if (symbol) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      symbol = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, symbol, submessage_arena);
    }
    
  } else {
    
  }
  symbol_ = symbol;
  // @@protoc_insertion_point(field_set_allocated:BaseData.Symbol)
}

// .bcl.DateTime Time = 5;
inline bool BaseData::_internal_has_time() const {
  return this != internal_default_instance() && time_ != nullptr;
}
inline bool BaseData::has_time() const {
  return _internal_has_time();
}
inline const ::bcl::DateTime& BaseData::_internal_time() const {
  const ::bcl::DateTime* p = time_;
  return p != nullptr ? *p : *reinterpret_cast<const ::bcl::DateTime*>(
      &::bcl::_DateTime_default_instance_);
}
inline const ::bcl::DateTime& BaseData::time() const {
  // @@protoc_insertion_point(field_get:BaseData.Time)
  return _internal_time();
}
inline ::bcl::DateTime* BaseData::release_time() {
  // @@protoc_insertion_point(field_release:BaseData.Time)
  
  ::bcl::DateTime* temp = time_;
  time_ = nullptr;
  return temp;
}
inline ::bcl::DateTime* BaseData::_internal_mutable_time() {
  
  if (time_ == nullptr) {
    auto* p = CreateMaybeMessage<::bcl::DateTime>(GetArenaNoVirtual());
    time_ = p;
  }
  return time_;
}
inline ::bcl::DateTime* BaseData::mutable_time() {
  // @@protoc_insertion_point(field_mutable:BaseData.Time)
  return _internal_mutable_time();
}
inline void BaseData::set_allocated_time(::bcl::DateTime* time) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(time_);
  }
  if (time) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      time = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, time, submessage_arena);
    }
    
  } else {
    
  }
  time_ = time;
  // @@protoc_insertion_point(field_set_allocated:BaseData.Time)
}

// .bcl.Decimal Value = 6;
inline bool BaseData::_internal_has_value() const {
  return this != internal_default_instance() && value_ != nullptr;
}
inline bool BaseData::has_value() const {
  return _internal_has_value();
}
inline const ::bcl::Decimal& BaseData::_internal_value() const {
  const ::bcl::Decimal* p = value_;
  return p != nullptr ? *p : *reinterpret_cast<const ::bcl::Decimal*>(
      &::bcl::_Decimal_default_instance_);
}
inline const ::bcl::Decimal& BaseData::value() const {
  // @@protoc_insertion_point(field_get:BaseData.Value)
  return _internal_value();
}
inline ::bcl::Decimal* BaseData::release_value() {
  // @@protoc_insertion_point(field_release:BaseData.Value)
  
  ::bcl::Decimal* temp = value_;
  value_ = nullptr;
  return temp;
}
inline ::bcl::Decimal* BaseData::_internal_mutable_value() {
  
  if (value_ == nullptr) {
    auto* p = CreateMaybeMessage<::bcl::Decimal>(GetArenaNoVirtual());
    value_ = p;
  }
  return value_;
}
inline ::bcl::Decimal* BaseData::mutable_value() {
  // @@protoc_insertion_point(field_mutable:BaseData.Value)
  return _internal_mutable_value();
}
inline void BaseData::set_allocated_value(::bcl::Decimal* value) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(value_);
  }
  if (value) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      value = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, value, submessage_arena);
    }
    
  } else {
    
  }
  value_ = value;
  // @@protoc_insertion_point(field_set_allocated:BaseData.Value)
}

// .TradeBar TradeBar = 200;
inline bool BaseData::_internal_has_tradebar() const {
  return subtype_case() == kTradeBar;
}
inline bool BaseData::has_tradebar() const {
  return _internal_has_tradebar();
}
inline void BaseData::set_has_tradebar() {
  _oneof_case_[0] = kTradeBar;
}
inline void BaseData::clear_tradebar() {
  if (_internal_has_tradebar()) {
    delete subtype_.tradebar_;
    clear_has_subtype();
  }
}
inline ::TradeBar* BaseData::release_tradebar() {
  // @@protoc_insertion_point(field_release:BaseData.TradeBar)
  if (_internal_has_tradebar()) {
    clear_has_subtype();
      ::TradeBar* temp = subtype_.tradebar_;
    subtype_.tradebar_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::TradeBar& BaseData::_internal_tradebar() const {
  return _internal_has_tradebar()
      ? *subtype_.tradebar_
      : *reinterpret_cast< ::TradeBar*>(&::_TradeBar_default_instance_);
}
inline const ::TradeBar& BaseData::tradebar() const {
  // @@protoc_insertion_point(field_get:BaseData.TradeBar)
  return _internal_tradebar();
}
inline ::TradeBar* BaseData::_internal_mutable_tradebar() {
  if (!_internal_has_tradebar()) {
    clear_subtype();
    set_has_tradebar();
    subtype_.tradebar_ = CreateMaybeMessage< ::TradeBar >(
        GetArenaNoVirtual());
  }
  return subtype_.tradebar_;
}
inline ::TradeBar* BaseData::mutable_tradebar() {
  // @@protoc_insertion_point(field_mutable:BaseData.TradeBar)
  return _internal_mutable_tradebar();
}

// .Tick Tick = 202;
inline bool BaseData::_internal_has_tick() const {
  return subtype_case() == kTick;
}
inline bool BaseData::has_tick() const {
  return _internal_has_tick();
}
inline void BaseData::set_has_tick() {
  _oneof_case_[0] = kTick;
}
inline void BaseData::clear_tick() {
  if (_internal_has_tick()) {
    delete subtype_.tick_;
    clear_has_subtype();
  }
}
inline ::Tick* BaseData::release_tick() {
  // @@protoc_insertion_point(field_release:BaseData.Tick)
  if (_internal_has_tick()) {
    clear_has_subtype();
      ::Tick* temp = subtype_.tick_;
    subtype_.tick_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::Tick& BaseData::_internal_tick() const {
  return _internal_has_tick()
      ? *subtype_.tick_
      : *reinterpret_cast< ::Tick*>(&::_Tick_default_instance_);
}
inline const ::Tick& BaseData::tick() const {
  // @@protoc_insertion_point(field_get:BaseData.Tick)
  return _internal_tick();
}
inline ::Tick* BaseData::_internal_mutable_tick() {
  if (!_internal_has_tick()) {
    clear_subtype();
    set_has_tick();
    subtype_.tick_ = CreateMaybeMessage< ::Tick >(
        GetArenaNoVirtual());
  }
  return subtype_.tick_;
}
inline ::Tick* BaseData::mutable_tick() {
  // @@protoc_insertion_point(field_mutable:BaseData.Tick)
  return _internal_mutable_tick();
}

inline bool BaseData::has_subtype() const {
  return subtype_case() != SUBTYPE_NOT_SET;
}
inline void BaseData::clear_has_subtype() {
  _oneof_case_[0] = SUBTYPE_NOT_SET;
}
inline BaseData::SubtypeCase BaseData::subtype_case() const {
  return BaseData::SubtypeCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// List_BaseData

// repeated .BaseData items = 1;
inline int List_BaseData::_internal_items_size() const {
  return items_.size();
}
inline int List_BaseData::items_size() const {
  return _internal_items_size();
}
inline void List_BaseData::clear_items() {
  items_.Clear();
}
inline ::BaseData* List_BaseData::mutable_items(int index) {
  // @@protoc_insertion_point(field_mutable:List_BaseData.items)
  return items_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::BaseData >*
List_BaseData::mutable_items() {
  // @@protoc_insertion_point(field_mutable_list:List_BaseData.items)
  return &items_;
}
inline const ::BaseData& List_BaseData::_internal_items(int index) const {
  return items_.Get(index);
}
inline const ::BaseData& List_BaseData::items(int index) const {
  // @@protoc_insertion_point(field_get:List_BaseData.items)
  return _internal_items(index);
}
inline ::BaseData* List_BaseData::_internal_add_items() {
  return items_.Add();
}
inline ::BaseData* List_BaseData::add_items() {
  // @@protoc_insertion_point(field_add:List_BaseData.items)
  return _internal_add_items();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::BaseData >&
List_BaseData::items() const {
  // @@protoc_insertion_point(field_list:List_BaseData.items)
  return items_;
}

// -------------------------------------------------------------------

// SecurityIdentifier

// string _symbol = 1;
inline void SecurityIdentifier::clear__symbol() {
  _symbol_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& SecurityIdentifier::_symbol() const {
  // @@protoc_insertion_point(field_get:SecurityIdentifier._symbol)
  return _internal__symbol();
}
inline void SecurityIdentifier::set__symbol(const std::string& value) {
  _internal_set__symbol(value);
  // @@protoc_insertion_point(field_set:SecurityIdentifier._symbol)
}
inline std::string* SecurityIdentifier::mutable__symbol() {
  // @@protoc_insertion_point(field_mutable:SecurityIdentifier._symbol)
  return _internal_mutable__symbol();
}
inline const std::string& SecurityIdentifier::_internal__symbol() const {
  return _symbol_.GetNoArena();
}
inline void SecurityIdentifier::_internal_set__symbol(const std::string& value) {
  
  _symbol_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void SecurityIdentifier::set__symbol(std::string&& value) {
  
  _symbol_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:SecurityIdentifier._symbol)
}
inline void SecurityIdentifier::set__symbol(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  _symbol_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:SecurityIdentifier._symbol)
}
inline void SecurityIdentifier::set__symbol(const char* value, size_t size) {
  
  _symbol_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:SecurityIdentifier._symbol)
}
inline std::string* SecurityIdentifier::_internal_mutable__symbol() {
  
  return _symbol_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* SecurityIdentifier::release__symbol() {
  // @@protoc_insertion_point(field_release:SecurityIdentifier._symbol)
  
  return _symbol_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void SecurityIdentifier::set_allocated__symbol(std::string* _symbol) {
  if (_symbol != nullptr) {
    
  } else {
    
  }
  _symbol_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), _symbol);
  // @@protoc_insertion_point(field_set_allocated:SecurityIdentifier._symbol)
}

// uint64 _properties = 2;
inline void SecurityIdentifier::clear__properties() {
  _properties_ = PROTOBUF_ULONGLONG(0);
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 SecurityIdentifier::_internal__properties() const {
  return _properties_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 SecurityIdentifier::_properties() const {
  // @@protoc_insertion_point(field_get:SecurityIdentifier._properties)
  return _internal__properties();
}
inline void SecurityIdentifier::_internal_set__properties(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  
  _properties_ = value;
}
inline void SecurityIdentifier::set__properties(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set__properties(value);
  // @@protoc_insertion_point(field_set:SecurityIdentifier._properties)
}

// .SidBox _underlying = 3;
inline bool SecurityIdentifier::_internal_has__underlying() const {
  return this != internal_default_instance() && _underlying_ != nullptr;
}
inline bool SecurityIdentifier::has__underlying() const {
  return _internal_has__underlying();
}
inline void SecurityIdentifier::clear__underlying() {
  if (GetArenaNoVirtual() == nullptr && _underlying_ != nullptr) {
    delete _underlying_;
  }
  _underlying_ = nullptr;
}
inline const ::SidBox& SecurityIdentifier::_internal__underlying() const {
  const ::SidBox* p = _underlying_;
  return p != nullptr ? *p : *reinterpret_cast<const ::SidBox*>(
      &::_SidBox_default_instance_);
}
inline const ::SidBox& SecurityIdentifier::_underlying() const {
  // @@protoc_insertion_point(field_get:SecurityIdentifier._underlying)
  return _internal__underlying();
}
inline ::SidBox* SecurityIdentifier::release__underlying() {
  // @@protoc_insertion_point(field_release:SecurityIdentifier._underlying)
  
  ::SidBox* temp = _underlying_;
  _underlying_ = nullptr;
  return temp;
}
inline ::SidBox* SecurityIdentifier::_internal_mutable__underlying() {
  
  if (_underlying_ == nullptr) {
    auto* p = CreateMaybeMessage<::SidBox>(GetArenaNoVirtual());
    _underlying_ = p;
  }
  return _underlying_;
}
inline ::SidBox* SecurityIdentifier::mutable__underlying() {
  // @@protoc_insertion_point(field_mutable:SecurityIdentifier._underlying)
  return _internal_mutable__underlying();
}
inline void SecurityIdentifier::set_allocated__underlying(::SidBox* _underlying) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete _underlying_;
  }
  if (_underlying) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      _underlying = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, _underlying, submessage_arena);
    }
    
  } else {
    
  }
  _underlying_ = _underlying;
  // @@protoc_insertion_point(field_set_allocated:SecurityIdentifier._underlying)
}

// int32 _hashCode = 4;
inline void SecurityIdentifier::clear__hashcode() {
  _hashcode_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 SecurityIdentifier::_internal__hashcode() const {
  return _hashcode_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 SecurityIdentifier::_hashcode() const {
  // @@protoc_insertion_point(field_get:SecurityIdentifier._hashCode)
  return _internal__hashcode();
}
inline void SecurityIdentifier::_internal_set__hashcode(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  _hashcode_ = value;
}
inline void SecurityIdentifier::set__hashcode(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set__hashcode(value);
  // @@protoc_insertion_point(field_set:SecurityIdentifier._hashCode)
}

// .bcl.Decimal _strikePrice = 5;
inline bool SecurityIdentifier::_internal_has__strikeprice() const {
  return this != internal_default_instance() && _strikeprice_ != nullptr;
}
inline bool SecurityIdentifier::has__strikeprice() const {
  return _internal_has__strikeprice();
}
inline const ::bcl::Decimal& SecurityIdentifier::_internal__strikeprice() const {
  const ::bcl::Decimal* p = _strikeprice_;
  return p != nullptr ? *p : *reinterpret_cast<const ::bcl::Decimal*>(
      &::bcl::_Decimal_default_instance_);
}
inline const ::bcl::Decimal& SecurityIdentifier::_strikeprice() const {
  // @@protoc_insertion_point(field_get:SecurityIdentifier._strikePrice)
  return _internal__strikeprice();
}
inline ::bcl::Decimal* SecurityIdentifier::release__strikeprice() {
  // @@protoc_insertion_point(field_release:SecurityIdentifier._strikePrice)
  
  ::bcl::Decimal* temp = _strikeprice_;
  _strikeprice_ = nullptr;
  return temp;
}
inline ::bcl::Decimal* SecurityIdentifier::_internal_mutable__strikeprice() {
  
  if (_strikeprice_ == nullptr) {
    auto* p = CreateMaybeMessage<::bcl::Decimal>(GetArenaNoVirtual());
    _strikeprice_ = p;
  }
  return _strikeprice_;
}
inline ::bcl::Decimal* SecurityIdentifier::mutable__strikeprice() {
  // @@protoc_insertion_point(field_mutable:SecurityIdentifier._strikePrice)
  return _internal_mutable__strikeprice();
}
inline void SecurityIdentifier::set_allocated__strikeprice(::bcl::Decimal* _strikeprice) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_strikeprice_);
  }
  if (_strikeprice) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      _strikeprice = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, _strikeprice, submessage_arena);
    }
    
  } else {
    
  }
  _strikeprice_ = _strikeprice;
  // @@protoc_insertion_point(field_set_allocated:SecurityIdentifier._strikePrice)
}

// .OptionStyle _optionStyle = 6;
inline void SecurityIdentifier::clear__optionstyle() {
  _optionstyle_ = 0;
}
inline ::OptionStyle SecurityIdentifier::_internal__optionstyle() const {
  return static_cast< ::OptionStyle >(_optionstyle_);
}
inline ::OptionStyle SecurityIdentifier::_optionstyle() const {
  // @@protoc_insertion_point(field_get:SecurityIdentifier._optionStyle)
  return _internal__optionstyle();
}
inline void SecurityIdentifier::_internal_set__optionstyle(::OptionStyle value) {
  
  _optionstyle_ = value;
}
inline void SecurityIdentifier::set__optionstyle(::OptionStyle value) {
  _internal_set__optionstyle(value);
  // @@protoc_insertion_point(field_set:SecurityIdentifier._optionStyle)
}

// .OptionRight _optionRight = 7;
inline void SecurityIdentifier::clear__optionright() {
  _optionright_ = 0;
}
inline ::OptionRight SecurityIdentifier::_internal__optionright() const {
  return static_cast< ::OptionRight >(_optionright_);
}
inline ::OptionRight SecurityIdentifier::_optionright() const {
  // @@protoc_insertion_point(field_get:SecurityIdentifier._optionRight)
  return _internal__optionright();
}
inline void SecurityIdentifier::_internal_set__optionright(::OptionRight value) {
  
  _optionright_ = value;
}
inline void SecurityIdentifier::set__optionright(::OptionRight value) {
  _internal_set__optionright(value);
  // @@protoc_insertion_point(field_set:SecurityIdentifier._optionRight)
}

// .bcl.DateTime _date = 8;
inline bool SecurityIdentifier::_internal_has__date() const {
  return this != internal_default_instance() && _date_ != nullptr;
}
inline bool SecurityIdentifier::has__date() const {
  return _internal_has__date();
}
inline const ::bcl::DateTime& SecurityIdentifier::_internal__date() const {
  const ::bcl::DateTime* p = _date_;
  return p != nullptr ? *p : *reinterpret_cast<const ::bcl::DateTime*>(
      &::bcl::_DateTime_default_instance_);
}
inline const ::bcl::DateTime& SecurityIdentifier::_date() const {
  // @@protoc_insertion_point(field_get:SecurityIdentifier._date)
  return _internal__date();
}
inline ::bcl::DateTime* SecurityIdentifier::release__date() {
  // @@protoc_insertion_point(field_release:SecurityIdentifier._date)
  
  ::bcl::DateTime* temp = _date_;
  _date_ = nullptr;
  return temp;
}
inline ::bcl::DateTime* SecurityIdentifier::_internal_mutable__date() {
  
  if (_date_ == nullptr) {
    auto* p = CreateMaybeMessage<::bcl::DateTime>(GetArenaNoVirtual());
    _date_ = p;
  }
  return _date_;
}
inline ::bcl::DateTime* SecurityIdentifier::mutable__date() {
  // @@protoc_insertion_point(field_mutable:SecurityIdentifier._date)
  return _internal_mutable__date();
}
inline void SecurityIdentifier::set_allocated__date(::bcl::DateTime* _date) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_date_);
  }
  if (_date) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      _date = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, _date, submessage_arena);
    }
    
  } else {
    
  }
  _date_ = _date;
  // @@protoc_insertion_point(field_set_allocated:SecurityIdentifier._date)
}

// .SecurityType SecurityType = 9;
inline void SecurityIdentifier::clear_securitytype() {
  securitytype_ = 0;
}
inline ::SecurityType SecurityIdentifier::_internal_securitytype() const {
  return static_cast< ::SecurityType >(securitytype_);
}
inline ::SecurityType SecurityIdentifier::securitytype() const {
  // @@protoc_insertion_point(field_get:SecurityIdentifier.SecurityType)
  return _internal_securitytype();
}
inline void SecurityIdentifier::_internal_set_securitytype(::SecurityType value) {
  
  securitytype_ = value;
}
inline void SecurityIdentifier::set_securitytype(::SecurityType value) {
  _internal_set_securitytype(value);
  // @@protoc_insertion_point(field_set:SecurityIdentifier.SecurityType)
}

// -------------------------------------------------------------------

// SidBox

// .SecurityIdentifier SecurityIdentifier = 1;
inline bool SidBox::_internal_has_securityidentifier() const {
  return this != internal_default_instance() && securityidentifier_ != nullptr;
}
inline bool SidBox::has_securityidentifier() const {
  return _internal_has_securityidentifier();
}
inline void SidBox::clear_securityidentifier() {
  if (GetArenaNoVirtual() == nullptr && securityidentifier_ != nullptr) {
    delete securityidentifier_;
  }
  securityidentifier_ = nullptr;
}
inline const ::SecurityIdentifier& SidBox::_internal_securityidentifier() const {
  const ::SecurityIdentifier* p = securityidentifier_;
  return p != nullptr ? *p : *reinterpret_cast<const ::SecurityIdentifier*>(
      &::_SecurityIdentifier_default_instance_);
}
inline const ::SecurityIdentifier& SidBox::securityidentifier() const {
  // @@protoc_insertion_point(field_get:SidBox.SecurityIdentifier)
  return _internal_securityidentifier();
}
inline ::SecurityIdentifier* SidBox::release_securityidentifier() {
  // @@protoc_insertion_point(field_release:SidBox.SecurityIdentifier)
  
  ::SecurityIdentifier* temp = securityidentifier_;
  securityidentifier_ = nullptr;
  return temp;
}
inline ::SecurityIdentifier* SidBox::_internal_mutable_securityidentifier() {
  
  if (securityidentifier_ == nullptr) {
    auto* p = CreateMaybeMessage<::SecurityIdentifier>(GetArenaNoVirtual());
    securityidentifier_ = p;
  }
  return securityidentifier_;
}
inline ::SecurityIdentifier* SidBox::mutable_securityidentifier() {
  // @@protoc_insertion_point(field_mutable:SidBox.SecurityIdentifier)
  return _internal_mutable_securityidentifier();
}
inline void SidBox::set_allocated_securityidentifier(::SecurityIdentifier* securityidentifier) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete securityidentifier_;
  }
  if (securityidentifier) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      securityidentifier = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, securityidentifier, submessage_arena);
    }
    
  } else {
    
  }
  securityidentifier_ = securityidentifier;
  // @@protoc_insertion_point(field_set_allocated:SidBox.SecurityIdentifier)
}

// -------------------------------------------------------------------

// Symbol

// bool HasUnderlying = 1;
inline void Symbol::clear_hasunderlying() {
  hasunderlying_ = false;
}
inline bool Symbol::_internal_hasunderlying() const {
  return hasunderlying_;
}
inline bool Symbol::hasunderlying() const {
  // @@protoc_insertion_point(field_get:Symbol.HasUnderlying)
  return _internal_hasunderlying();
}
inline void Symbol::_internal_set_hasunderlying(bool value) {
  
  hasunderlying_ = value;
}
inline void Symbol::set_hasunderlying(bool value) {
  _internal_set_hasunderlying(value);
  // @@protoc_insertion_point(field_set:Symbol.HasUnderlying)
}

// .SecurityIdentifier ID = 2;
inline bool Symbol::_internal_has_id() const {
  return this != internal_default_instance() && id_ != nullptr;
}
inline bool Symbol::has_id() const {
  return _internal_has_id();
}
inline void Symbol::clear_id() {
  if (GetArenaNoVirtual() == nullptr && id_ != nullptr) {
    delete id_;
  }
  id_ = nullptr;
}
inline const ::SecurityIdentifier& Symbol::_internal_id() const {
  const ::SecurityIdentifier* p = id_;
  return p != nullptr ? *p : *reinterpret_cast<const ::SecurityIdentifier*>(
      &::_SecurityIdentifier_default_instance_);
}
inline const ::SecurityIdentifier& Symbol::id() const {
  // @@protoc_insertion_point(field_get:Symbol.ID)
  return _internal_id();
}
inline ::SecurityIdentifier* Symbol::release_id() {
  // @@protoc_insertion_point(field_release:Symbol.ID)
  
  ::SecurityIdentifier* temp = id_;
  id_ = nullptr;
  return temp;
}
inline ::SecurityIdentifier* Symbol::_internal_mutable_id() {
  
  if (id_ == nullptr) {
    auto* p = CreateMaybeMessage<::SecurityIdentifier>(GetArenaNoVirtual());
    id_ = p;
  }
  return id_;
}
inline ::SecurityIdentifier* Symbol::mutable_id() {
  // @@protoc_insertion_point(field_mutable:Symbol.ID)
  return _internal_mutable_id();
}
inline void Symbol::set_allocated_id(::SecurityIdentifier* id) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete id_;
  }
  if (id) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      id = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, id, submessage_arena);
    }
    
  } else {
    
  }
  id_ = id;
  // @@protoc_insertion_point(field_set_allocated:Symbol.ID)
}

// .SecurityType SecurityType = 3;
inline void Symbol::clear_securitytype() {
  securitytype_ = 0;
}
inline ::SecurityType Symbol::_internal_securitytype() const {
  return static_cast< ::SecurityType >(securitytype_);
}
inline ::SecurityType Symbol::securitytype() const {
  // @@protoc_insertion_point(field_get:Symbol.SecurityType)
  return _internal_securitytype();
}
inline void Symbol::_internal_set_securitytype(::SecurityType value) {
  
  securitytype_ = value;
}
inline void Symbol::set_securitytype(::SecurityType value) {
  _internal_set_securitytype(value);
  // @@protoc_insertion_point(field_set:Symbol.SecurityType)
}

// .Symbol Underlying = 4;
inline bool Symbol::_internal_has_underlying() const {
  return this != internal_default_instance() && underlying_ != nullptr;
}
inline bool Symbol::has_underlying() const {
  return _internal_has_underlying();
}
inline void Symbol::clear_underlying() {
  if (GetArenaNoVirtual() == nullptr && underlying_ != nullptr) {
    delete underlying_;
  }
  underlying_ = nullptr;
}
inline const ::Symbol& Symbol::_internal_underlying() const {
  const ::Symbol* p = underlying_;
  return p != nullptr ? *p : *reinterpret_cast<const ::Symbol*>(
      &::_Symbol_default_instance_);
}
inline const ::Symbol& Symbol::underlying() const {
  // @@protoc_insertion_point(field_get:Symbol.Underlying)
  return _internal_underlying();
}
inline ::Symbol* Symbol::release_underlying() {
  // @@protoc_insertion_point(field_release:Symbol.Underlying)
  
  ::Symbol* temp = underlying_;
  underlying_ = nullptr;
  return temp;
}
inline ::Symbol* Symbol::_internal_mutable_underlying() {
  
  if (underlying_ == nullptr) {
    auto* p = CreateMaybeMessage<::Symbol>(GetArenaNoVirtual());
    underlying_ = p;
  }
  return underlying_;
}
inline ::Symbol* Symbol::mutable_underlying() {
  // @@protoc_insertion_point(field_mutable:Symbol.Underlying)
  return _internal_mutable_underlying();
}
inline void Symbol::set_allocated_underlying(::Symbol* underlying) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete underlying_;
  }
  if (underlying) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      underlying = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, underlying, submessage_arena);
    }
    
  } else {
    
  }
  underlying_ = underlying;
  // @@protoc_insertion_point(field_set_allocated:Symbol.Underlying)
}

// string Value = 5;
inline void Symbol::clear_value() {
  value_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& Symbol::value() const {
  // @@protoc_insertion_point(field_get:Symbol.Value)
  return _internal_value();
}
inline void Symbol::set_value(const std::string& value) {
  _internal_set_value(value);
  // @@protoc_insertion_point(field_set:Symbol.Value)
}
inline std::string* Symbol::mutable_value() {
  // @@protoc_insertion_point(field_mutable:Symbol.Value)
  return _internal_mutable_value();
}
inline const std::string& Symbol::_internal_value() const {
  return value_.GetNoArena();
}
inline void Symbol::_internal_set_value(const std::string& value) {
  
  value_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void Symbol::set_value(std::string&& value) {
  
  value_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:Symbol.Value)
}
inline void Symbol::set_value(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  value_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Symbol.Value)
}
inline void Symbol::set_value(const char* value, size_t size) {
  
  value_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Symbol.Value)
}
inline std::string* Symbol::_internal_mutable_value() {
  
  return value_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* Symbol::release_value() {
  // @@protoc_insertion_point(field_release:Symbol.Value)
  
  return value_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void Symbol::set_allocated_value(std::string* value) {
  if (value != nullptr) {
    
  } else {
    
  }
  value_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set_allocated:Symbol.Value)
}

// -------------------------------------------------------------------

// Tick

// .bcl.Decimal AskPrice = 1;
inline bool Tick::_internal_has_askprice() const {
  return this != internal_default_instance() && askprice_ != nullptr;
}
inline bool Tick::has_askprice() const {
  return _internal_has_askprice();
}
inline const ::bcl::Decimal& Tick::_internal_askprice() const {
  const ::bcl::Decimal* p = askprice_;
  return p != nullptr ? *p : *reinterpret_cast<const ::bcl::Decimal*>(
      &::bcl::_Decimal_default_instance_);
}
inline const ::bcl::Decimal& Tick::askprice() const {
  // @@protoc_insertion_point(field_get:Tick.AskPrice)
  return _internal_askprice();
}
inline ::bcl::Decimal* Tick::release_askprice() {
  // @@protoc_insertion_point(field_release:Tick.AskPrice)
  
  ::bcl::Decimal* temp = askprice_;
  askprice_ = nullptr;
  return temp;
}
inline ::bcl::Decimal* Tick::_internal_mutable_askprice() {
  
  if (askprice_ == nullptr) {
    auto* p = CreateMaybeMessage<::bcl::Decimal>(GetArenaNoVirtual());
    askprice_ = p;
  }
  return askprice_;
}
inline ::bcl::Decimal* Tick::mutable_askprice() {
  // @@protoc_insertion_point(field_mutable:Tick.AskPrice)
  return _internal_mutable_askprice();
}
inline void Tick::set_allocated_askprice(::bcl::Decimal* askprice) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(askprice_);
  }
  if (askprice) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      askprice = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, askprice, submessage_arena);
    }
    
  } else {
    
  }
  askprice_ = askprice;
  // @@protoc_insertion_point(field_set_allocated:Tick.AskPrice)
}

// .bcl.Decimal AskSize = 2;
inline bool Tick::_internal_has_asksize() const {
  return this != internal_default_instance() && asksize_ != nullptr;
}
inline bool Tick::has_asksize() const {
  return _internal_has_asksize();
}
inline const ::bcl::Decimal& Tick::_internal_asksize() const {
  const ::bcl::Decimal* p = asksize_;
  return p != nullptr ? *p : *reinterpret_cast<const ::bcl::Decimal*>(
      &::bcl::_Decimal_default_instance_);
}
inline const ::bcl::Decimal& Tick::asksize() const {
  // @@protoc_insertion_point(field_get:Tick.AskSize)
  return _internal_asksize();
}
inline ::bcl::Decimal* Tick::release_asksize() {
  // @@protoc_insertion_point(field_release:Tick.AskSize)
  
  ::bcl::Decimal* temp = asksize_;
  asksize_ = nullptr;
  return temp;
}
inline ::bcl::Decimal* Tick::_internal_mutable_asksize() {
  
  if (asksize_ == nullptr) {
    auto* p = CreateMaybeMessage<::bcl::Decimal>(GetArenaNoVirtual());
    asksize_ = p;
  }
  return asksize_;
}
inline ::bcl::Decimal* Tick::mutable_asksize() {
  // @@protoc_insertion_point(field_mutable:Tick.AskSize)
  return _internal_mutable_asksize();
}
inline void Tick::set_allocated_asksize(::bcl::Decimal* asksize) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(asksize_);
  }
  if (asksize) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      asksize = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, asksize, submessage_arena);
    }
    
  } else {
    
  }
  asksize_ = asksize;
  // @@protoc_insertion_point(field_set_allocated:Tick.AskSize)
}

// .bcl.Decimal BidPrice = 3;
inline bool Tick::_internal_has_bidprice() const {
  return this != internal_default_instance() && bidprice_ != nullptr;
}
inline bool Tick::has_bidprice() const {
  return _internal_has_bidprice();
}
inline const ::bcl::Decimal& Tick::_internal_bidprice() const {
  const ::bcl::Decimal* p = bidprice_;
  return p != nullptr ? *p : *reinterpret_cast<const ::bcl::Decimal*>(
      &::bcl::_Decimal_default_instance_);
}
inline const ::bcl::Decimal& Tick::bidprice() const {
  // @@protoc_insertion_point(field_get:Tick.BidPrice)
  return _internal_bidprice();
}
inline ::bcl::Decimal* Tick::release_bidprice() {
  // @@protoc_insertion_point(field_release:Tick.BidPrice)
  
  ::bcl::Decimal* temp = bidprice_;
  bidprice_ = nullptr;
  return temp;
}
inline ::bcl::Decimal* Tick::_internal_mutable_bidprice() {
  
  if (bidprice_ == nullptr) {
    auto* p = CreateMaybeMessage<::bcl::Decimal>(GetArenaNoVirtual());
    bidprice_ = p;
  }
  return bidprice_;
}
inline ::bcl::Decimal* Tick::mutable_bidprice() {
  // @@protoc_insertion_point(field_mutable:Tick.BidPrice)
  return _internal_mutable_bidprice();
}
inline void Tick::set_allocated_bidprice(::bcl::Decimal* bidprice) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(bidprice_);
  }
  if (bidprice) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      bidprice = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, bidprice, submessage_arena);
    }
    
  } else {
    
  }
  bidprice_ = bidprice;
  // @@protoc_insertion_point(field_set_allocated:Tick.BidPrice)
}

// .bcl.Decimal BidSize = 4;
inline bool Tick::_internal_has_bidsize() const {
  return this != internal_default_instance() && bidsize_ != nullptr;
}
inline bool Tick::has_bidsize() const {
  return _internal_has_bidsize();
}
inline const ::bcl::Decimal& Tick::_internal_bidsize() const {
  const ::bcl::Decimal* p = bidsize_;
  return p != nullptr ? *p : *reinterpret_cast<const ::bcl::Decimal*>(
      &::bcl::_Decimal_default_instance_);
}
inline const ::bcl::Decimal& Tick::bidsize() const {
  // @@protoc_insertion_point(field_get:Tick.BidSize)
  return _internal_bidsize();
}
inline ::bcl::Decimal* Tick::release_bidsize() {
  // @@protoc_insertion_point(field_release:Tick.BidSize)
  
  ::bcl::Decimal* temp = bidsize_;
  bidsize_ = nullptr;
  return temp;
}
inline ::bcl::Decimal* Tick::_internal_mutable_bidsize() {
  
  if (bidsize_ == nullptr) {
    auto* p = CreateMaybeMessage<::bcl::Decimal>(GetArenaNoVirtual());
    bidsize_ = p;
  }
  return bidsize_;
}
inline ::bcl::Decimal* Tick::mutable_bidsize() {
  // @@protoc_insertion_point(field_mutable:Tick.BidSize)
  return _internal_mutable_bidsize();
}
inline void Tick::set_allocated_bidsize(::bcl::Decimal* bidsize) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(bidsize_);
  }
  if (bidsize) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      bidsize = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, bidsize, submessage_arena);
    }
    
  } else {
    
  }
  bidsize_ = bidsize;
  // @@protoc_insertion_point(field_set_allocated:Tick.BidSize)
}

// string Exchange = 5;
inline void Tick::clear_exchange() {
  exchange_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& Tick::exchange() const {
  // @@protoc_insertion_point(field_get:Tick.Exchange)
  return _internal_exchange();
}
inline void Tick::set_exchange(const std::string& value) {
  _internal_set_exchange(value);
  // @@protoc_insertion_point(field_set:Tick.Exchange)
}
inline std::string* Tick::mutable_exchange() {
  // @@protoc_insertion_point(field_mutable:Tick.Exchange)
  return _internal_mutable_exchange();
}
inline const std::string& Tick::_internal_exchange() const {
  return exchange_.GetNoArena();
}
inline void Tick::_internal_set_exchange(const std::string& value) {
  
  exchange_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void Tick::set_exchange(std::string&& value) {
  
  exchange_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:Tick.Exchange)
}
inline void Tick::set_exchange(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  exchange_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Tick.Exchange)
}
inline void Tick::set_exchange(const char* value, size_t size) {
  
  exchange_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Tick.Exchange)
}
inline std::string* Tick::_internal_mutable_exchange() {
  
  return exchange_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* Tick::release_exchange() {
  // @@protoc_insertion_point(field_release:Tick.Exchange)
  
  return exchange_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void Tick::set_allocated_exchange(std::string* exchange) {
  if (exchange != nullptr) {
    
  } else {
    
  }
  exchange_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), exchange);
  // @@protoc_insertion_point(field_set_allocated:Tick.Exchange)
}

// .bcl.Decimal Quantity = 6;
inline bool Tick::_internal_has_quantity() const {
  return this != internal_default_instance() && quantity_ != nullptr;
}
inline bool Tick::has_quantity() const {
  return _internal_has_quantity();
}
inline const ::bcl::Decimal& Tick::_internal_quantity() const {
  const ::bcl::Decimal* p = quantity_;
  return p != nullptr ? *p : *reinterpret_cast<const ::bcl::Decimal*>(
      &::bcl::_Decimal_default_instance_);
}
inline const ::bcl::Decimal& Tick::quantity() const {
  // @@protoc_insertion_point(field_get:Tick.Quantity)
  return _internal_quantity();
}
inline ::bcl::Decimal* Tick::release_quantity() {
  // @@protoc_insertion_point(field_release:Tick.Quantity)
  
  ::bcl::Decimal* temp = quantity_;
  quantity_ = nullptr;
  return temp;
}
inline ::bcl::Decimal* Tick::_internal_mutable_quantity() {
  
  if (quantity_ == nullptr) {
    auto* p = CreateMaybeMessage<::bcl::Decimal>(GetArenaNoVirtual());
    quantity_ = p;
  }
  return quantity_;
}
inline ::bcl::Decimal* Tick::mutable_quantity() {
  // @@protoc_insertion_point(field_mutable:Tick.Quantity)
  return _internal_mutable_quantity();
}
inline void Tick::set_allocated_quantity(::bcl::Decimal* quantity) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(quantity_);
  }
  if (quantity) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      quantity = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, quantity, submessage_arena);
    }
    
  } else {
    
  }
  quantity_ = quantity;
  // @@protoc_insertion_point(field_set_allocated:Tick.Quantity)
}

// string SaleCondition = 7;
inline void Tick::clear_salecondition() {
  salecondition_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& Tick::salecondition() const {
  // @@protoc_insertion_point(field_get:Tick.SaleCondition)
  return _internal_salecondition();
}
inline void Tick::set_salecondition(const std::string& value) {
  _internal_set_salecondition(value);
  // @@protoc_insertion_point(field_set:Tick.SaleCondition)
}
inline std::string* Tick::mutable_salecondition() {
  // @@protoc_insertion_point(field_mutable:Tick.SaleCondition)
  return _internal_mutable_salecondition();
}
inline const std::string& Tick::_internal_salecondition() const {
  return salecondition_.GetNoArena();
}
inline void Tick::_internal_set_salecondition(const std::string& value) {
  
  salecondition_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void Tick::set_salecondition(std::string&& value) {
  
  salecondition_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:Tick.SaleCondition)
}
inline void Tick::set_salecondition(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  salecondition_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Tick.SaleCondition)
}
inline void Tick::set_salecondition(const char* value, size_t size) {
  
  salecondition_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Tick.SaleCondition)
}
inline std::string* Tick::_internal_mutable_salecondition() {
  
  return salecondition_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* Tick::release_salecondition() {
  // @@protoc_insertion_point(field_release:Tick.SaleCondition)
  
  return salecondition_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void Tick::set_allocated_salecondition(std::string* salecondition) {
  if (salecondition != nullptr) {
    
  } else {
    
  }
  salecondition_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), salecondition);
  // @@protoc_insertion_point(field_set_allocated:Tick.SaleCondition)
}

// bool Suspicious = 8;
inline void Tick::clear_suspicious() {
  suspicious_ = false;
}
inline bool Tick::_internal_suspicious() const {
  return suspicious_;
}
inline bool Tick::suspicious() const {
  // @@protoc_insertion_point(field_get:Tick.Suspicious)
  return _internal_suspicious();
}
inline void Tick::_internal_set_suspicious(bool value) {
  
  suspicious_ = value;
}
inline void Tick::set_suspicious(bool value) {
  _internal_set_suspicious(value);
  // @@protoc_insertion_point(field_set:Tick.Suspicious)
}

// .TickType TickType = 9;
inline void Tick::clear_ticktype() {
  ticktype_ = 0;
}
inline ::TickType Tick::_internal_ticktype() const {
  return static_cast< ::TickType >(ticktype_);
}
inline ::TickType Tick::ticktype() const {
  // @@protoc_insertion_point(field_get:Tick.TickType)
  return _internal_ticktype();
}
inline void Tick::_internal_set_ticktype(::TickType value) {
  
  ticktype_ = value;
}
inline void Tick::set_ticktype(::TickType value) {
  _internal_set_ticktype(value);
  // @@protoc_insertion_point(field_set:Tick.TickType)
}

// -------------------------------------------------------------------

// TradeBar

// .bcl.Decimal Close = 1;
inline bool TradeBar::_internal_has_close() const {
  return this != internal_default_instance() && close_ != nullptr;
}
inline bool TradeBar::has_close() const {
  return _internal_has_close();
}
inline const ::bcl::Decimal& TradeBar::_internal_close() const {
  const ::bcl::Decimal* p = close_;
  return p != nullptr ? *p : *reinterpret_cast<const ::bcl::Decimal*>(
      &::bcl::_Decimal_default_instance_);
}
inline const ::bcl::Decimal& TradeBar::close() const {
  // @@protoc_insertion_point(field_get:TradeBar.Close)
  return _internal_close();
}
inline ::bcl::Decimal* TradeBar::release_close() {
  // @@protoc_insertion_point(field_release:TradeBar.Close)
  
  ::bcl::Decimal* temp = close_;
  close_ = nullptr;
  return temp;
}
inline ::bcl::Decimal* TradeBar::_internal_mutable_close() {
  
  if (close_ == nullptr) {
    auto* p = CreateMaybeMessage<::bcl::Decimal>(GetArenaNoVirtual());
    close_ = p;
  }
  return close_;
}
inline ::bcl::Decimal* TradeBar::mutable_close() {
  // @@protoc_insertion_point(field_mutable:TradeBar.Close)
  return _internal_mutable_close();
}
inline void TradeBar::set_allocated_close(::bcl::Decimal* close) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(close_);
  }
  if (close) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      close = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, close, submessage_arena);
    }
    
  } else {
    
  }
  close_ = close;
  // @@protoc_insertion_point(field_set_allocated:TradeBar.Close)
}

// .bcl.DateTime EndTime = 2;
inline bool TradeBar::_internal_has_endtime() const {
  return this != internal_default_instance() && endtime_ != nullptr;
}
inline bool TradeBar::has_endtime() const {
  return _internal_has_endtime();
}
inline const ::bcl::DateTime& TradeBar::_internal_endtime() const {
  const ::bcl::DateTime* p = endtime_;
  return p != nullptr ? *p : *reinterpret_cast<const ::bcl::DateTime*>(
      &::bcl::_DateTime_default_instance_);
}
inline const ::bcl::DateTime& TradeBar::endtime() const {
  // @@protoc_insertion_point(field_get:TradeBar.EndTime)
  return _internal_endtime();
}
inline ::bcl::DateTime* TradeBar::release_endtime() {
  // @@protoc_insertion_point(field_release:TradeBar.EndTime)
  
  ::bcl::DateTime* temp = endtime_;
  endtime_ = nullptr;
  return temp;
}
inline ::bcl::DateTime* TradeBar::_internal_mutable_endtime() {
  
  if (endtime_ == nullptr) {
    auto* p = CreateMaybeMessage<::bcl::DateTime>(GetArenaNoVirtual());
    endtime_ = p;
  }
  return endtime_;
}
inline ::bcl::DateTime* TradeBar::mutable_endtime() {
  // @@protoc_insertion_point(field_mutable:TradeBar.EndTime)
  return _internal_mutable_endtime();
}
inline void TradeBar::set_allocated_endtime(::bcl::DateTime* endtime) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(endtime_);
  }
  if (endtime) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      endtime = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, endtime, submessage_arena);
    }
    
  } else {
    
  }
  endtime_ = endtime;
  // @@protoc_insertion_point(field_set_allocated:TradeBar.EndTime)
}

// .bcl.Decimal High = 3;
inline bool TradeBar::_internal_has_high() const {
  return this != internal_default_instance() && high_ != nullptr;
}
inline bool TradeBar::has_high() const {
  return _internal_has_high();
}
inline const ::bcl::Decimal& TradeBar::_internal_high() const {
  const ::bcl::Decimal* p = high_;
  return p != nullptr ? *p : *reinterpret_cast<const ::bcl::Decimal*>(
      &::bcl::_Decimal_default_instance_);
}
inline const ::bcl::Decimal& TradeBar::high() const {
  // @@protoc_insertion_point(field_get:TradeBar.High)
  return _internal_high();
}
inline ::bcl::Decimal* TradeBar::release_high() {
  // @@protoc_insertion_point(field_release:TradeBar.High)
  
  ::bcl::Decimal* temp = high_;
  high_ = nullptr;
  return temp;
}
inline ::bcl::Decimal* TradeBar::_internal_mutable_high() {
  
  if (high_ == nullptr) {
    auto* p = CreateMaybeMessage<::bcl::Decimal>(GetArenaNoVirtual());
    high_ = p;
  }
  return high_;
}
inline ::bcl::Decimal* TradeBar::mutable_high() {
  // @@protoc_insertion_point(field_mutable:TradeBar.High)
  return _internal_mutable_high();
}
inline void TradeBar::set_allocated_high(::bcl::Decimal* high) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(high_);
  }
  if (high) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      high = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, high, submessage_arena);
    }
    
  } else {
    
  }
  high_ = high;
  // @@protoc_insertion_point(field_set_allocated:TradeBar.High)
}

// .bcl.Decimal Low = 4;
inline bool TradeBar::_internal_has_low() const {
  return this != internal_default_instance() && low_ != nullptr;
}
inline bool TradeBar::has_low() const {
  return _internal_has_low();
}
inline const ::bcl::Decimal& TradeBar::_internal_low() const {
  const ::bcl::Decimal* p = low_;
  return p != nullptr ? *p : *reinterpret_cast<const ::bcl::Decimal*>(
      &::bcl::_Decimal_default_instance_);
}
inline const ::bcl::Decimal& TradeBar::low() const {
  // @@protoc_insertion_point(field_get:TradeBar.Low)
  return _internal_low();
}
inline ::bcl::Decimal* TradeBar::release_low() {
  // @@protoc_insertion_point(field_release:TradeBar.Low)
  
  ::bcl::Decimal* temp = low_;
  low_ = nullptr;
  return temp;
}
inline ::bcl::Decimal* TradeBar::_internal_mutable_low() {
  
  if (low_ == nullptr) {
    auto* p = CreateMaybeMessage<::bcl::Decimal>(GetArenaNoVirtual());
    low_ = p;
  }
  return low_;
}
inline ::bcl::Decimal* TradeBar::mutable_low() {
  // @@protoc_insertion_point(field_mutable:TradeBar.Low)
  return _internal_mutable_low();
}
inline void TradeBar::set_allocated_low(::bcl::Decimal* low) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(low_);
  }
  if (low) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      low = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, low, submessage_arena);
    }
    
  } else {
    
  }
  low_ = low;
  // @@protoc_insertion_point(field_set_allocated:TradeBar.Low)
}

// .bcl.Decimal Open = 5;
inline bool TradeBar::_internal_has_open() const {
  return this != internal_default_instance() && open_ != nullptr;
}
inline bool TradeBar::has_open() const {
  return _internal_has_open();
}
inline const ::bcl::Decimal& TradeBar::_internal_open() const {
  const ::bcl::Decimal* p = open_;
  return p != nullptr ? *p : *reinterpret_cast<const ::bcl::Decimal*>(
      &::bcl::_Decimal_default_instance_);
}
inline const ::bcl::Decimal& TradeBar::open() const {
  // @@protoc_insertion_point(field_get:TradeBar.Open)
  return _internal_open();
}
inline ::bcl::Decimal* TradeBar::release_open() {
  // @@protoc_insertion_point(field_release:TradeBar.Open)
  
  ::bcl::Decimal* temp = open_;
  open_ = nullptr;
  return temp;
}
inline ::bcl::Decimal* TradeBar::_internal_mutable_open() {
  
  if (open_ == nullptr) {
    auto* p = CreateMaybeMessage<::bcl::Decimal>(GetArenaNoVirtual());
    open_ = p;
  }
  return open_;
}
inline ::bcl::Decimal* TradeBar::mutable_open() {
  // @@protoc_insertion_point(field_mutable:TradeBar.Open)
  return _internal_mutable_open();
}
inline void TradeBar::set_allocated_open(::bcl::Decimal* open) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(open_);
  }
  if (open) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      open = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, open, submessage_arena);
    }
    
  } else {
    
  }
  open_ = open;
  // @@protoc_insertion_point(field_set_allocated:TradeBar.Open)
}

// .bcl.TimeSpan Period = 6;
inline bool TradeBar::_internal_has_period() const {
  return this != internal_default_instance() && period_ != nullptr;
}
inline bool TradeBar::has_period() const {
  return _internal_has_period();
}
inline const ::bcl::TimeSpan& TradeBar::_internal_period() const {
  const ::bcl::TimeSpan* p = period_;
  return p != nullptr ? *p : *reinterpret_cast<const ::bcl::TimeSpan*>(
      &::bcl::_TimeSpan_default_instance_);
}
inline const ::bcl::TimeSpan& TradeBar::period() const {
  // @@protoc_insertion_point(field_get:TradeBar.Period)
  return _internal_period();
}
inline ::bcl::TimeSpan* TradeBar::release_period() {
  // @@protoc_insertion_point(field_release:TradeBar.Period)
  
  ::bcl::TimeSpan* temp = period_;
  period_ = nullptr;
  return temp;
}
inline ::bcl::TimeSpan* TradeBar::_internal_mutable_period() {
  
  if (period_ == nullptr) {
    auto* p = CreateMaybeMessage<::bcl::TimeSpan>(GetArenaNoVirtual());
    period_ = p;
  }
  return period_;
}
inline ::bcl::TimeSpan* TradeBar::mutable_period() {
  // @@protoc_insertion_point(field_mutable:TradeBar.Period)
  return _internal_mutable_period();
}
inline void TradeBar::set_allocated_period(::bcl::TimeSpan* period) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(period_);
  }
  if (period) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      period = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, period, submessage_arena);
    }
    
  } else {
    
  }
  period_ = period;
  // @@protoc_insertion_point(field_set_allocated:TradeBar.Period)
}

// .bcl.Decimal Volume = 7;
inline bool TradeBar::_internal_has_volume() const {
  return this != internal_default_instance() && volume_ != nullptr;
}
inline bool TradeBar::has_volume() const {
  return _internal_has_volume();
}
inline const ::bcl::Decimal& TradeBar::_internal_volume() const {
  const ::bcl::Decimal* p = volume_;
  return p != nullptr ? *p : *reinterpret_cast<const ::bcl::Decimal*>(
      &::bcl::_Decimal_default_instance_);
}
inline const ::bcl::Decimal& TradeBar::volume() const {
  // @@protoc_insertion_point(field_get:TradeBar.Volume)
  return _internal_volume();
}
inline ::bcl::Decimal* TradeBar::release_volume() {
  // @@protoc_insertion_point(field_release:TradeBar.Volume)
  
  ::bcl::Decimal* temp = volume_;
  volume_ = nullptr;
  return temp;
}
inline ::bcl::Decimal* TradeBar::_internal_mutable_volume() {
  
  if (volume_ == nullptr) {
    auto* p = CreateMaybeMessage<::bcl::Decimal>(GetArenaNoVirtual());
    volume_ = p;
  }
  return volume_;
}
inline ::bcl::Decimal* TradeBar::mutable_volume() {
  // @@protoc_insertion_point(field_mutable:TradeBar.Volume)
  return _internal_mutable_volume();
}
inline void TradeBar::set_allocated_volume(::bcl::Decimal* volume) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(volume_);
  }
  if (volume) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      volume = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, volume, submessage_arena);
    }
    
  } else {
    
  }
  volume_ = volume;
  // @@protoc_insertion_point(field_set_allocated:TradeBar.Volume)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)


PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::MarketDataType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::MarketDataType>() {
  return ::MarketDataType_descriptor();
}
template <> struct is_proto_enum< ::OptionRight> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::OptionRight>() {
  return ::OptionRight_descriptor();
}
template <> struct is_proto_enum< ::OptionStyle> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::OptionStyle>() {
  return ::OptionStyle_descriptor();
}
template <> struct is_proto_enum< ::SecurityType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::SecurityType>() {
  return ::SecurityType_descriptor();
}
template <> struct is_proto_enum< ::TickType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::TickType>() {
  return ::TickType_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_qc_2eproto
